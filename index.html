<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é€Ÿæˆå¤§å†’éšª | Quick Input Adventure V28</title>
    
    <!-- Core Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'brand': { 50: '#f0f9ff', 100: '#e0f2fe', 500: '#0ea5e9', 600: '#0284c7' },
                        'magic': { 950: '#1e1b4b', 900: '#2e1065', 800: '#4c1d95', 600: '#7c3aed', 500: '#8b5cf6', 300: '#c4b5fd', 100: '#ede9fe' },
                        'gold': { 400: '#facc15', 500: '#eab308', 600: '#ca8a04' },
                        'danger': { 900: '#450a0a', 500: '#ef4444' }
                    },
                    fontFamily: {
                        'serif': ['"Noto Serif TC"', '"Songti TC"', 'serif'],
                        'sans': ['"Noto Sans TC"', 'sans-serif'],
                        'mono': ['"Noto Sans Mono"', 'monospace'],
                    },
                    animation: {
                        'shake': 'shake 0.5s cubic-bezier(.36,.07,.19,.97) both',
                        'pulse-glow': 'pulseGlow 2s infinite',
                        'damage-flash': 'damageFlash 0.3s ease-in-out',
                        'float-up': 'floatUp 1s ease-out forwards',
                        'coin-spin': 'coinSpin 1s linear infinite',
                        'wiggle': 'wiggle 1s ease-in-out infinite',
                    },
                    keyframes: {
                        shake: { '10%, 90%': { transform: 'translate3d(-2px, 0, 0)' }, '20%, 80%': { transform: 'translate3d(4px, 0, 0)' }, '30%, 50%, 70%': { transform: 'translate3d(-6px, 0, 0)' }, '40%, 60%': { transform: 'translate3d(6px, 0, 0)' } },
                        pulseGlow: { '0%, 100%': { opacity: 1, filter: 'brightness(1)' }, '50%': { opacity: 0.8, filter: 'brightness(1.3)' } },
                        damageFlash: { '0%, 100%': { backgroundColor: 'transparent' }, '50%': { backgroundColor: 'rgba(239, 68, 68, 0.3)' } },
                        floatUp: { '0%': { transform: 'translateY(0) scale(1)', opacity: 1 }, '100%': { transform: 'translateY(-50px) scale(1.5)', opacity: 0 } },
                        coinSpin: { '0%': { transform: 'rotateY(0deg)' }, '100%': { transform: 'rotateY(360deg)' } },
                        wiggle: { '0%, 100%': { transform: 'rotate(-3deg)' }, '50%': { transform: 'rotate(3deg)' } }
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700;900&family=Noto+Serif+TC:wght@700&display=swap');
        html, body, #root { height: 100%; margin: 0; padding: 0; font-family: 'Noto Sans TC', sans-serif; overflow: hidden; touch-action: manipulation; background-color: #f8fafc; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .keyboard-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 4px; }
        .perspective-road { transform: perspective(500px) rotateX(40deg); transform-origin: 50% 100%; }
        .blind-blur { filter: blur(4px); user-select: none; opacity: 0.5; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const { motion, AnimatePresence } = window.Motion;
        const { icons } = lucide;
        const { 
            Settings, Volume2, ArrowLeft, Play, User, Trophy, Star, Zap, LayoutGrid, Rocket, Heart, AlertTriangle, 
            CheckCircle, RefreshCw, Keyboard, MousePointer2, Box, Home, Trees, Cloud, Moon, Flag, Timer, Leaf, 
            Smile, Coffee, BookOpen, Sword, Shield, Ghost, Sparkles, Skull, Flame, Plus, Crown, Gift, Hammer, 
            Droplets, Wind, Eye, Save, Upload, Download, X, Coins, GraduationCap, Lock, Unlock, ShoppingBag, 
            Tent, BedDouble, Dumbbell, Gem, Gauge, EyeOff, MicOff, Shuffle
        } = icons;

        const LucideIcon = ({ icon, size = 24, className = "" }) => icon ? <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{icon.map(([tag, attrs], i) => React.createElement(tag, { ...attrs, key: i }))}</svg> : null;

        // --- ğŸµ Audio Engine ---
        const AudioEngine = {
            ctx: null,
            init: function() { 
                if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
                if (this.ctx.state === 'suspended') { this.ctx.resume(); }
            },
            playTone: function(freq, type, duration, vol = 0.1, slideTo = null) {
                if (!this.ctx) this.init();
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator(); 
                const gain = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, t);
                if (slideTo) { osc.frequency.exponentialRampToValueAtTime(slideTo, t + duration); }
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(vol, t + 0.02); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + duration);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + duration);
            },
            correct: function() { this.playTone(880, 'sine', 0.2, 0.1); setTimeout(() => this.playTone(1108, 'sine', 0.3, 0.1), 50); },
            wrong: function() { this.playTone(150, 'triangle', 0.3, 0.15, 100); },
            click: function() { this.playTone(1200, 'sine', 0.03, 0.02); },
            attack: function() { this.playTone(200, 'triangle', 0.15, 0.1, 50); }, 
            crit: function() { this.playTone(600, 'square', 0.1, 0.05, 1200); }, 
            hit: function() { this.playTone(100, 'triangle', 0.2, 0.15, 50); },
            skill: function() { this.playTone(300, 'sine', 0.4, 0.1, 600); },
            levelUp: function() { [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => setTimeout(() => this.playTone(f, 'sine', 0.3, 0.1), i * 80)); },
            win: function() { [523, 659, 784, 1046, 784, 1046].forEach((f, i) => setTimeout(() => this.playTone(f, 'triangle', 0.2, 0.1), i * 120)); },
            lose: function() { [392, 370, 349, 330].forEach((f, i) => setTimeout(() => this.playTone(f, 'triangle', 0.4, 0.1), i * 300)); },
            coin: function() { this.playTone(1318, 'sine', 0.1, 0.05); setTimeout(() => this.playTone(1975, 'sine', 0.2, 0.05), 80); },
            heal: function() { this.playTone(400, 'sine', 0.6, 0.1, 800); },
            powerUp: function() { this.playTone(440, 'sine', 0.1, 0.1); setTimeout(() => this.playTone(554, 'sine', 0.1, 0.1), 60); setTimeout(() => this.playTone(659, 'sine', 0.2, 0.1), 120); }
        };

        // --- ğŸ“š Data & Utils ---
        const KEYBOARD_MAP = { 'A': 'æ—¥', 'B': 'æœˆ', 'C': 'é‡‘', 'D': 'æœ¨', 'E': 'æ°´', 'F': 'ç«', 'G': 'åœŸ', 'H': 'ç«¹', 'I': 'æˆˆ', 'J': 'å', 'K': 'å¤§', 'L': 'ä¸­', 'M': 'ä¸€', 'N': 'å¼“', 'O': 'äºº', 'P': 'å¿ƒ', 'Q': 'æ‰‹', 'R': 'å£', 'S': 'å°¸', 'T': 'å»¿', 'U': 'å±±', 'V': 'å¥³', 'W': 'ç”°', 'X': 'é›£', 'Y': 'åœ', 'Z': 'é‡' };
        
        const CHAPTERS = [
            { id: '01', code: 'A', name: 'æ—¥' }, { id: '02', code: 'B', name: 'æœˆ' }, { id: '03', code: 'C', name: 'é‡‘' }, { id: '04', code: 'D', name: 'æœ¨' },
            { id: '05', code: 'E', name: 'æ°´' }, { id: '06', code: 'F', name: 'ç«' }, { id: '07', code: 'G', name: 'åœŸ' }, { id: '08', code: 'H', name: 'ç«¹' },
            { id: '09', code: 'I', name: 'æˆˆ' }, { id: '10', code: 'J', name: 'å' }, { id: '11', code: 'K', name: 'å¤§' }, { id: '12', code: 'L', name: 'ä¸­' },
            { id: '13', code: 'M', name: 'ä¸€' }, { id: '14', code: 'N', name: 'å¼“' }, { id: '15', code: 'O', name: 'äºº' }, { id: '16', code: 'P', name: 'å¿ƒ' },
            { id: '17', code: 'Q', name: 'æ‰‹' }, { id: '18', code: 'R', name: 'å£' }, { id: '19', code: 'S', name: 'å°¸' }, { id: '20', code: 'T', name: 'å»¿' },
            { id: '21', code: 'U', name: 'å±±' }, { id: '22', code: 'V', name: 'å¥³' }, { id: '23', code: 'W', name: 'ç”°' }, { id: '24', code: 'Y', name: 'åœ' },
            { id: '25', code: 'X', name: 'é›£' }
        ];

        const THEMES = {
            FOREST: { bg: 'bg-gradient-to-b from-sky-300 to-blue-100', road: 'from-slate-700 to-slate-900', decor: Trees }
        };

        const MONSTER_TYPES = [
            { name: 'å²èŠå§†', hpMod: 0.8, atkMod: 0.8, speedMod: 0.8, color: 'text-green-400', icon: Ghost, effect: 'confusion', effectName: 'æ··äº‚' },
            { name: 'è™è ', hpMod: 0.6, atkMod: 1.2, speedMod: 1.5, color: 'text-purple-400', icon: Wind, effect: 'blind', effectName: 'è‡´ç›²' },
            { name: 'çŸ³åƒé¬¼', hpMod: 1.5, atkMod: 1.0, speedMod: 0.6, color: 'text-stone-400', icon: Shield, effect: 'silence', effectName: 'å°å°' },
            { name: 'æš—å½±åˆºå®¢', hpMod: 0.8, atkMod: 1.5, speedMod: 1.2, color: 'text-red-400', icon: Sword, effect: 'blind', effectName: 'è‡´ç›²' },
            { name: 'å­—éˆé¾', hpMod: 2.5, atkMod: 1.5, speedMod: 1.0, color: 'text-yellow-400', icon: Crown, isBoss: true, effect: 'silence', effectName: 'é¾å¨' },
            { name: 'æ·±æ·µé ˜ä¸»', hpMod: 3.0, atkMod: 1.8, speedMod: 0.8, color: 'text-rose-500', icon: Skull, isBoss: true, effect: 'confusion', effectName: 'ææ‡¼' },
        ];

        // ğŸ“š Corrected Question Bank (Full Cangjie Codes)
        const QUESTIONS = [
            // A - æ—¥
            { mainCode: 'A', char: "æ™¤", code: "AMMR", hint: "æ—¥ä¸€ä¸€å£" }, { mainCode: 'A', char: "æ—¦", code: "AM", hint: "æ—¥ä¸€" },
            { mainCode: 'A', char: "æš—", code: "AYTA", hint: "æ—¥åœå»¿æ—¥" }, { mainCode: 'A', char: "æ›™", code: "AWLA", hint: "æ—¥ç”°ä¸­æ—¥" },
            { mainCode: 'A', char: "æ™…", code: "AMGM", hint: "æ—¥ä¸€åœŸä¸€" }, { mainCode: 'A', char: "æ™‚", code: "AGDI", hint: "æ—¥åœŸæœ¨æˆˆ" }, 
            { mainCode: 'A', char: "æ™¯", code: "AYRF", hint: "æ—¥åœå£ç«" }, { mainCode: 'A', char: "ç…§", code: "ASRF", hint: "æ—¥å°¸å£ç«" },
            { mainCode: 'A', char: "é¡Œ", code: "AMBC", hint: "æ—¥ä¸€æœˆé‡‘" }, { mainCode: 'A', char: "æš", code: "ABAC", hint: "æ—¥æœˆæ—¥é‡‘" },
            { mainCode: 'A', char: "æ™š", code: "ANAU", hint: "æ—¥å¼“æ—¥å±±" }, { mainCode: 'A', char: "å•", code: "ANR", hint: "æ—¥å¼“å£" }, 
            { mainCode: 'A', char: "é–€", code: "AN", hint: "æ—¥å¼“" }, { mainCode: 'A', char: "æ˜“", code: "APH", hint: "æ—¥å¿ƒç«¹" }, 
            { mainCode: 'A', char: "å½±", code: "AYHH", hint: "æ—¥åœç«¹ç«¹" }, { mainCode: 'A', char: "å³", code: "AIL", hint: "æ—¥æˆˆä¸­" },

            // B - æœˆ
            { mainCode: 'B', char: "æœ‹", code: "BB", hint: "æœˆæœˆ" }, { mainCode: 'B', char: "è³„", code: "BUKB", hint: "æœˆå±±å¤§æœˆ" }, 
            { mainCode: 'B', char: "ä¸”", code: "BM", hint: "æœˆä¸€" }, { mainCode: 'B', char: "è³ ", code: "BUYR", hint: "æœˆå±±åœå£" }, 
            { mainCode: 'B', char: "ç‚™", code: "BKF", hint: "æœˆå¤§ç«" }, { mainCode: 'B', char: "éª¨", code: "BBB", hint: "æœˆæœˆæœˆ" },
            { mainCode: 'B', char: "è‡‰", code: "BOMM", hint: "æœˆäººäººä¸€" }, { mainCode: 'B', char: "è²¼", code: "BUYR", hint: "æœˆå±±åœå£" }, 
            { mainCode: 'B', char: "è³­", code: "BUJA", hint: "æœˆå±±åæ—¥" }, { mainCode: 'B', char: "è†½", code: "BNCR", hint: "æœˆå¼“é‡‘å£" }, 
            { mainCode: 'B', char: "å…·", code: "BMC", hint: "æœˆä¸€é‡‘" }, { mainCode: 'B', char: "è³º", code: "BUTXC", hint: "æœˆå±±å»¿é›£é‡‘" }, 
            { mainCode: 'B', char: "è‚š", code: "BG", hint: "æœˆåœŸ" }, { mainCode: 'B', char: "ç¦", code: "BUG", hint: "æœˆå±±åœŸ" },
            { mainCode: 'B', char: "è²¡", code: "BUD", hint: "æœˆå±±æœ¨" }, { mainCode: 'B', char: "å† ", code: "BMUI", hint: "æœˆä¸€å±±æˆˆ" },
            { mainCode: 'B', char: "è…³", code: "BGIL", hint: "æœˆåœŸæˆˆä¸­" }, { mainCode: 'B', char: "å‰›", code: "BKLN", hint: "æœˆå¤§ä¸­å¼“" },

            // C - é‡‘
            { mainCode: 'C', char: "éŒ¯", code: "CTA", hint: "é‡‘å»¿æ—¥" }, { mainCode: 'C', char: "éŠ·", code: "CFB", hint: "é‡‘ç«æœˆ" }, 
            { mainCode: 'C', char: "é‹ª", code: "CIJB", hint: "é‡‘æˆˆåæœˆ" }, { mainCode: 'C', char: "æ›¾", code: "CWA", hint: "é‡‘ç”°æ—¥" },
            { mainCode: 'C', char: "é‘½", code: "CHUC", hint: "é‡‘ç«¹å±±é‡‘" }, { mainCode: 'C', char: "é–", code: "CFBC", hint: "é‡‘ç«æœˆé‡‘" }, 
            { mainCode: 'C', char: "éŒ¢", code: "CII", hint: "é‡‘æˆˆæˆˆ" }, { mainCode: 'C', char: "é", code: "CITOE", hint: "é‡‘æˆˆå»¿äººæ°´" },
            { mainCode: 'C', char: "é‹°", code: "CWG", hint: "é‡‘ç”°åœŸ" }, { mainCode: 'C', char: "éˆ•", code: "CNG", hint: "é‡‘å¼“åœŸ" }, 
            { mainCode: 'C', char: "åˆ†", code: "CSH", hint: "é‡‘å°¸ç«¹" }, { mainCode: 'C', char: "å¼Ÿ", code: "CNH", hint: "é‡‘å¼“ç«¹" }, 
            { mainCode: 'C', char: "çˆ¶", code: "CK", hint: "é‡‘å¤§" }, { mainCode: 'C', char: "å»", code: "CRIL", hint: "é‡‘å£æˆˆä¸­" },

            // D - æœ¨
            { mainCode: 'D', char: "æŸ", code: "DHA", hint: "æœ¨ç«¹æ—¥" }, { mainCode: 'D', char: "æ©‹", code: "DHKB", hint: "æœ¨ç«¹å¤§æœˆ" },
            { mainCode: 'D', char: "è³´", code: "DLBUC", hint: "æœ¨ä¸­æœˆå±±é‡‘" }, { mainCode: 'D', char: "æ«ƒ", code: "DSLC", hint: "æœ¨å°¸ä¸­é‡‘" }, 
            { mainCode: 'D', char: "æ©«", code: "DTLC", hint: "æœ¨å»¿ä¸­é‡‘" }, { mainCode: 'D', char: "æ£‹", code: "DTMC", hint: "æœ¨å»¿ä¸€é‡‘" }, 
            { mainCode: 'D', char: "æœ", code: "DG", hint: "æœ¨åœŸ" }, { mainCode: 'D', char: "æ¯", code: "DMF", hint: "æœ¨ä¸€ç«" },
            { mainCode: 'D', char: "ç¦", code: "DDMMF", hint: "æœ¨æœ¨ä¸€ä¸€ç«" }, { mainCode: 'D', char: "æ©Ÿ", code: "DVII", hint: "æœ¨å¥³æˆˆæˆˆ" },
            { mainCode: 'D', char: "æƒ³", code: "DBUP", hint: "æœ¨æœˆå±±å¿ƒ" }, { mainCode: 'D', char: "æ•´", code: "DLMK", hint: "æœ¨ä¸­ä¸€å¤§" }, 

            // E - æ°´
            { mainCode: 'E', char: "æ³¢", code: "EDHE", hint: "æ°´æœ¨ç«¹æ°´" }, { mainCode: 'E', char: "æ¹–", code: "EJRB", hint: "æ°´åå£æœˆ" },
            { mainCode: 'E', char: "æ·‡", code: "ETMC", hint: "æ°´å»¿ä¸€é‡‘" }, { mainCode: 'E', char: "æ½›", code: "EQOA", hint: "æ°´æ‰‹äººæ—¥" },
            { mainCode: 'E', char: "æ³Š", code: "EHA", hint: "æ°´ç«¹æ—¥" }, { mainCode: 'E', char: "æ¾—", code: "EANA", hint: "æ°´æ—¥å¼“æ—¥" },
            { mainCode: 'E', char: "æº", code: "ETTB", hint: "æ°´å»¿å»¿æœˆ" }, { mainCode: 'E', char: "æ»¿", code: "ETMB", hint: "æ°´å»¿ä¸€æœˆ" },
            { mainCode: 'E', char: "æ¶ˆ", code: "EFB", hint: "æ°´ç«æœˆ" }, { mainCode: 'E', char: "æ½®", code: "EJJB", hint: "æ°´ååæœˆ" },
            { mainCode: 'E', char: "æ»‘", code: "EBBB", hint: "æ°´æœˆæœˆæœˆ" }, { mainCode: 'E', char: "æ·ª", code: "EOMB", hint: "æ°´äººä¸€æœˆ" },
            { mainCode: 'E', char: "æ·±", code: "EBCD", hint: "æ°´æœˆé‡‘æœ¨" }, { mainCode: 'E', char: "æ·¨", code: "EBSD", hint: "æ°´æœˆå°¸æœ¨" },
            { mainCode: 'E', char: "æŸ“", code: "END", hint: "æ°´å¼“æœ¨" }, { mainCode: 'E', char: "æ¸¸", code: "EYSD", hint: "æ°´åœå°¸æœ¨" },
            { mainCode: 'E', char: "æ¢", code: "EID", hint: "æ°´æˆˆæœ¨" }, { mainCode: 'E', char: "æ³¨", code: "EYG", hint: "æ°´åœåœŸ" }, 
            { mainCode: 'E', char: "ç˜", code: "ETOG", hint: "æ°´å»¿äººåœŸ" }, { mainCode: 'E', char: "æ¹¯", code: "EASH", hint: "æ°´æ—¥å°¸ç«¹" },
            { mainCode: 'E', char: "æ²™", code: "EFH", hint: "æ°´ç«ç«¹" }, 

            // F - ç«
            { mainCode: 'F', char: "ç²¾", code: "FDQMB", hint: "ç«æœ¨æ‰‹ä¸€æœˆ" }, { mainCode: 'F', char: "å˜—", code: "FBRPA", hint: "ç«æœˆå£å¿ƒæ—¥" },
            { mainCode: 'F', char: "å¸¸", code: "FBLB", hint: "ç«æœˆä¸­æœˆ" }, { mainCode: 'F', char: "å¹£", code: "FKLB", hint: "ç«å¤§ä¸­æœˆ" },
            { mainCode: 'F', char: "ç…©", code: "FMBC", hint: "ç«ä¸€æœˆé‡‘" }, { mainCode: 'F', char: "è³", code: "FBRBC", hint: "ç«æœˆå£æœˆé‡‘" },
            { mainCode: 'F', char: "é¡", code: "FDMBC", hint: "ç«æœ¨ä¸€æœˆé‡‘" }, { mainCode: 'F', char: "ç±³", code: "FD", hint: "ç«æœ¨" },
            { mainCode: 'F', char: "ç…¤", code: "FDTM", hint: "ç«æœ¨å»¿ä¸€" }, { mainCode: 'F', char: "æ¦®", code: "FFBD", hint: "ç«ç«æœˆæœ¨" },
            { mainCode: 'F', char: "ç‡¦", code: "FYED", hint: "ç«åœæ°´æœ¨" }, { mainCode: 'F', char: "ç„¶", code: "BKF", hint: "æœˆå¤§ç«" }, 
            { mainCode: 'F', char: "ç¥­", code: "BOF", hint: "æœˆäººç«" }, { mainCode: 'F', char: "æ¯", code: "DMF", hint: "æœ¨ä¸€ç«" }, 
            { mainCode: 'F', char: "ç¦", code: "DDMMF", hint: "æœ¨æœ¨ä¸€ä¸€ç«" }, 

            // G - åœŸ
            { mainCode: 'G', char: "å¢", code: "GCWA", hint: "åœŸé‡‘ç”°æ—¥" }, { mainCode: 'G', char: "å¹«", code: "GQBL", hint: "åœŸæ‰‹æœˆä¸­" },
            { mainCode: 'G', char: "ç†±", code: "GCIF", hint: "åœŸé‡‘æˆˆç«" }, { mainCode: 'G', char: "åœ°", code: "GPD", hint: "åœŸå¿ƒæœ¨" },
            { mainCode: 'G', char: "åŸ”", code: "GIB", hint: "åœŸæˆˆæœˆ" }, { mainCode: 'G', char: "åœ¾", code: "GNE", hint: "åœŸå¼“æ°´" }, 
            { mainCode: 'G', char: "å ±", code: "GTLE", hint: "åœŸå»¿ä¸­æ°´" }, { mainCode: 'G', char: "å †", code: "GOG", hint: "åœŸäººåœŸ" },
            { mainCode: 'G', char: "å»", code: "GI", hint: "åœŸæˆˆ" }, { mainCode: 'G', char: "å†", code: "GB", hint: "åœŸæœˆ" }, 
            { mainCode: 'G', char: "æ•´", code: "GK", hint: "åœŸå¤§" }, { mainCode: 'G', char: "å‡", code: "GG", hint: "åœŸåœŸ" }, 
            { mainCode: 'G', char: "å‹", code: "GCN", hint: "åœŸé‡‘å¼“" }, { mainCode: 'G', char: "å ´", code: "GASH", hint: "åœŸæ—¥å°¸ç«¹" },
            { mainCode: 'G', char: "å½­", code: "GTHHH", hint: "åœŸå»¿ç«¹ç«¹ç«¹" }, 

            // H - ç«¹
            { mainCode: 'H', char: "ç™½", code: "HA", hint: "ç«¹æ—¥" }, { mainCode: 'H', char: "é¦™", code: "HDA", hint: "ç«¹æœ¨æ—¥" },
            { mainCode: 'H', char: "ç¦¾", code: "HD", hint: "ç«¹æœ¨" }, { mainCode: 'H', char: "èˆ‡", code: "HXC", hint: "ç«¹é›£é‡‘" },
            { mainCode: 'H', char: "é¡§", code: "HMBC", hint: "ç«¹ä¸€æœˆé‡‘" }, { mainCode: 'H', char: "é ˆ", code: "HHMBC", hint: "ç«¹ç«¹ä¸€æœˆé‡‘" },
            { mainCode: 'H', char: "è´Š", code: "HUOC", hint: "ç«¹å±±äººé‡‘" }, { mainCode: 'H', char: "è³ª", code: "HFBC", hint: "ç«¹ç«æœˆé‡‘" },
            { mainCode: 'H', char: "èˆˆ", code: "HXBC", hint: "ç«¹é›£æœˆé‡‘" }, { mainCode: 'H', char: "ç©", code: "HDQC", hint: "ç«¹æœ¨æ‰‹é‡‘" },
            { mainCode: 'H', char: "é‡", code: "HGMG", hint: "ç«¹åœŸä¸€åœŸ" }, { mainCode: 'H', char: "ç¨®", code: "HDHG", hint: "ç«¹æœ¨ç«¹åœŸ" },
            { mainCode: 'H', char: "å¾€", code: "HOYG", hint: "ç«¹äººåœåœŸ" }, { mainCode: 'H', char: "ç¨‹", code: "HDRHG", hint: "ç«¹æœ¨å£ç«¹åœŸ" },
            { mainCode: 'H', char: "çš‡", code: "HAG", hint: "ç«¹æ—¥åœŸ" }, { mainCode: 'H', char: "ç§‹", code: "HDF", hint: "ç«¹æœ¨ç«" },
            { mainCode: 'H', char: "é³¥", code: "HAF", hint: "ç«¹æ—¥ç«" }, { mainCode: 'H', char: "æ‰€", code: "HML", hint: "ç«¹ä¸€ä¸­" },
            { mainCode: 'H', char: "ç¬¬", code: "HCNH", hint: "ç«¹é‡‘å¼“ç«¹" }, { mainCode: 'H', char: "èº«", code: "HXH", hint: "ç«¹é›£ç«¹" }, 
            { mainCode: 'H', char: "ç‰©", code: "HQPPH", hint: "ç«¹æ‰‹å¿ƒå¿ƒç«¹" }, { mainCode: 'H', char: "ç§’", code: "HDCH", hint: "ç«¹æœ¨é‡‘ç«¹" },
            { mainCode: 'H', char: "æˆ‘", code: "HQI", hint: "ç«¹æ‰‹æˆˆ" }, { mainCode: 'H', char: "å¾—", code: "HOAMI", hint: "ç«¹äººæ—¥ä¸€æˆˆ" }, 
            { mainCode: 'H', char: "ç­‰", code: "HGDI", hint: "ç«¹åœŸæœ¨æˆˆ" }, { mainCode: 'H', char: "ç§", code: "HDI", hint: "ç«¹æœ¨æˆˆ" }, 
            { mainCode: 'H', char: "å†¬", code: "HE", hint: "ç«¹æ°´" }, 

            // I - æˆˆ
            { mainCode: 'I', char: "æˆ–", code: "IRM", hint: "æˆˆå£ä¸€" }, { mainCode: 'I', char: "å¼", code: "IPM", hint: "æˆˆå¿ƒä¸€" },
            { mainCode: 'I', char: "ç¤¾", code: "IFG", hint: "æˆˆç«åœŸ" }, { mainCode: 'I', char: "åƒ", code: "IIH", hint: "æˆˆæˆˆç«¹" }, 
            { mainCode: 'I', char: "å†·", code: "IMOII", hint: "æˆˆä¸€äººæˆˆæˆˆ" }, { mainCode: 'I', char: "ç‚º", code: "IKF", hint: "æˆˆå¤§ç«" }, 
            { mainCode: 'I', char: "åº¦", code: "ITE", hint: "æˆˆå»¿æ°´" }, 

            // J - å
            { mainCode: 'J', char: "è€…", code: "JKA", hint: "åå¤§æ—¥" }, { mainCode: 'J', char: "è»Š", code: "JJ", hint: "åå" },
            { mainCode: 'J', char: "å—", code: "JBJ", hint: "åæœˆå" }, { mainCode: 'J', char: "çœŸ", code: "JBC", hint: "åæœˆé‡‘" },
            { mainCode: 'J', char: "å¯¦", code: "JBUC", hint: "åæœˆå±±é‡‘" }, { mainCode: 'J', char: "å¯¶", code: "JMBC", hint: "åä¸€æœˆé‡‘" },
            { mainCode: 'J', char: "å®‡", code: "JMD", hint: "åä¸€æœ¨" }, { mainCode: 'J', char: "å­—", code: "JND", hint: "åå¼“æœ¨" },
            { mainCode: 'J', char: "æ¡ˆ", code: "JVD", hint: "åå¥³æœ¨" }, { mainCode: 'J', char: "å¯«", code: "JHKF", hint: "åç«¹å¤§ç«" },
            { mainCode: 'J', char: "å¯Ÿ", code: "JBOF", hint: "åæœˆäººç«" }, { mainCode: 'J', char: "å®¤", code: "JMIG", hint: "åä¸€æˆˆåœŸ" },
            { mainCode: 'J', char: "åš", code: "JIBI", hint: "åæˆˆæœˆæˆˆ" }, { mainCode: 'J', char: "å°ˆ", code: "JIDI", hint: "åæˆˆæœ¨æˆˆ" },
            { mainCode: 'J', char: "éƒ½", code: "JAL", hint: "åæ—¥ä¸­" }, { mainCode: 'J', char: "ç©º", code: "JM", hint: "åä¸€" },
            { mainCode: 'J', char: "æ•™", code: "JK", hint: "åå¤§" }, { mainCode: 'J', char: "è½", code: "JSMIP", hint: "åå°¸ä¸€æˆˆå¿ƒ" }, 

            // K - å¤§
            { mainCode: 'K', char: "æœ‰", code: "KB", hint: "å¤§æœˆ" }, { mainCode: 'K', char: "ç—›", code: "KNIB", hint: "å¤§å¼“æˆˆæœˆ" },
            { mainCode: 'K', char: "å¸¶", code: "KPNB", hint: "å¤§å¿ƒæœˆæœˆ" }, { mainCode: 'K', char: "å¸Œ", code: "KKB", hint: "å¤§å¤§æœˆ" },
            { mainCode: 'K', char: "åœ¨", code: "KLG", hint: "å¤§ä¸­åœŸ" }, { mainCode: 'K', char: "å¤ª", code: "KI", hint: "å¤§æˆˆ" },
            { mainCode: 'K', char: "å·¦", code: "KM", hint: "å¤§ä¸€" }, 

            // L - ä¸­
            { mainCode: 'L', char: "æ›¸", code: "LGA", hint: "ä¸­åœŸæ—¥" }, { mainCode: 'L', char: "è²´", code: "LMBC", hint: "ä¸­ä¸€æœˆé‡‘" }, 
            { mainCode: 'L', char: "è²»", code: "LNBC", hint: "ä¸­å¼“æœˆé‡‘" }, { mainCode: 'L', char: "è¢«", code: "LDHE", hint: "ä¸­æœ¨ç«¹æ°´" }, 
            { mainCode: 'L', char: "è£¡", code: "LWG", hint: "ä¸­ç”°åœŸ" }, { mainCode: 'L', char: "åˆ", code: "LCSH", hint: "ä¸­é‡‘å°¸ç«¹" }, 
            { mainCode: 'L', char: "æ•¸", code: "LVOK", hint: "ä¸­å¥³äººå¤§" }, { mainCode: 'L', char: "å²", code: "JL", hint: "ä¸­å¤§" }, 
            { mainCode: 'L', char: "å¤®", code: "LBK", hint: "ä¸­æœˆå¤§" }, { mainCode: 'L', char: "å¿ ", code: "LP", hint: "ä¸­å¿ƒ" },
            { mainCode: 'L', char: "æ‚²", code: "LMYP", hint: "ä¸­ä¸€åœå¿ƒ" }, { mainCode: 'L', char: "é–‰", code: "LS", hint: "ä¸­å°¸" }, 

            // M - ä¸€
            { mainCode: 'M', char: "ç™¾", code: "MA", hint: "ä¸€æ—¥" }, { mainCode: 'M', char: "å¤©", code: "MK", hint: "ä¸€å¤§" }, 
            { mainCode: 'M', char: "è‡³", code: "MIG", hint: "ä¸€æˆˆåœŸ" }, { mainCode: 'M', char: "é¢", code: "MWYL", hint: "ä¸€ç”°åœä¸­" },
            { mainCode: 'M', char: "æ", code: "MNIP", hint: "ä¸€å¼“æˆˆå¿ƒ" }, 

            // N - å¼“
            { mainCode: 'N', char: "éˆ•", code: "CNG", hint: "é‡‘å¼“åœŸ" }, { mainCode: 'N', char: "é™Œ", code: "NLMA", hint: "å¼“ä¸­ä¸€æ—¥" }, 
            { mainCode: 'N', char: "éš¨", code: "NLKB", hint: "å¼“ä¸­å¤§æœˆ" }, { mainCode: 'N', char: "å­", code: "ND", hint: "å¼“æœ¨" }, 
            { mainCode: 'N', char: "é™¤", code: "NLOD", hint: "å¼“ä¸­äººæœ¨" }, { mainCode: 'N', char: "ç™¼", code: "NOHNE", hint: "å¼“äººç«¹æ°´" }, 
            { mainCode: 'N', char: "å­«", code: "NDNF", hint: "å¼“æœ¨å¼“ç«" }, { mainCode: 'N', char: "é­š", code: "NWF", hint: "å¼“ç”°ç«" }, 
            { mainCode: 'N', char: "é™£", code: "NLJJ", hint: "å¼“ä¸­åå" }, { mainCode: 'N', char: "é™½", code: "NLAM", hint: "å¼“ä¸­æ—¥ä¸€" }, 

            // O - äºº
            { mainCode: 'O', char: "ä½ ", code: "ONF", hint: "äººå¼“ç«" }, { mainCode: 'O', char: "ä»–", code: "OPD", hint: "äººå¿ƒæœ¨" },
            { mainCode: 'O', char: "ä¼‘", code: "OD", hint: "äººæœ¨" }, { mainCode: 'O', char: "æœƒ", code: "OMA", hint: "äººä¸€æ—¥" },
            { mainCode: 'O', char: "ä¾¿", code: "OMK", hint: "äººä¸€å¤§" }, { mainCode: 'O', char: "åš", code: "OJRK", hint: "äººåå£å¤§" },
            { mainCode: 'O', char: "ä½¿", code: "OJLK", hint: "äººåä¸­å¤§" }, { mainCode: 'O', char: "å€Ÿ", code: "OTA", hint: "äººå»¿æ—¥" },
            { mainCode: 'O', char: "ä¾†", code: "DOO", hint: "æœ¨äººäºº" }, // D start
            { mainCode: 'O', char: "ä½", code: "OYG", hint: "äººåœåœŸ" },
            { mainCode: 'O', char: "å", code: "OOG", hint: "äººäººåœŸ" },

            // P - å¿ƒ
            { mainCode: 'P', char: "æ€•", code: "PHA", hint: "å¿ƒç«¹æ—¥" }, { mainCode: 'P', char: "æƒ…", code: "PQMB", hint: "å¿ƒæ‰‹ä¸€æœˆ" },
            { mainCode: 'P', char: "å¿™", code: "PYV", hint: "å¿ƒåœå¥³" }, { mainCode: 'P', char: "å¿", code: "SIP", hint: "å°¸æˆˆå¿ƒ" }, 
            { mainCode: 'P', char: "å¿«", code: "PDK", hint: "å¿ƒæœ¨å¤§" }, { mainCode: 'P', char: "å¿½", code: "PPHP", hint: "å¿ƒå¿ƒç«¹å¿ƒ" },

            // Q - æ‰‹
            { mainCode: 'Q', char: "æŒ‡", code: "QPA", hint: "æ‰‹å¿ƒæ—¥" }, { mainCode: 'Q', char: "æ‹", code: "QHA", hint: "æ‰‹ç«¹æ—¥" },
            { mainCode: 'Q', char: "æƒ", code: "QSMB", hint: "æ‰‹å°¸ä¸€æœˆ" }, { mainCode: 'Q', char: "æ", code: "QYRB", hint: "æ‰‹åœå£æœˆ" },
            { mainCode: 'Q', char: "æ•", code: "QIJB", hint: "æ‰‹æˆˆåæœˆ" }, { mainCode: 'Q', char: "æ¨", code: "QOG", hint: "æ‰‹äººåœŸ" },
            { mainCode: 'Q', char: "æ®", code: "QBJJ", hint: "æ‰‹æœˆåå" }, { mainCode: 'Q', char: "æ›", code: "QNBK", hint: "æ‰‹å¼“æœˆå¤§" }, 
            { mainCode: 'Q', char: "æ“‡", code: "QWLJ", hint: "æ‰‹ç”°ä¸­å" }, { mainCode: 'Q', char: "æ’", code: "QHJX", hint: "æ‰‹ç«¹åé›£" },

            // R - å£
            { mainCode: 'R', char: "å”±", code: "RAA", hint: "å£æ—¥æ—¥" }, { mainCode: 'R', char: "å˜´", code: "RYPB", hint: "å£åœå¿ƒæœˆ" },
            { mainCode: 'R', char: "å“­", code: "RRIK", hint: "å£å£æˆˆå¤§" }, { mainCode: 'R', char: "åƒ", code: "RON", hint: "å£äººå¼“" }, 
            { mainCode: 'R', char: "å“ª", code: "RSQL", hint: "å£å°¸æ‰‹ä¸­" }, { mainCode: 'R', char: "å‘€", code: "RMVH", hint: "å£ä¸€å¥³ç«¹" }, 
            { mainCode: 'R', char: "å“¦", code: "RHQI", hint: "å£ç«¹æ‰‹æˆˆ" },

            // S - å°¸
            { mainCode: 'S', char: "å±¤", code: "SCWA", hint: "å°¸é‡‘ç”°æ—¥" }, { mainCode: 'S', char: "å±‹", code: "SMIG", hint: "å°¸ä¸€æˆˆåœŸ" },
            { mainCode: 'S', char: "å±…", code: "SJR", hint: "å°¸åå£" }, { mainCode: 'S', char: "å±€", code: "SSR", hint: "å°¸å°¸å£" },
            { mainCode: 'S', char: "å±¬", code: "SHYI", hint: "å°¸ç«¹åœæˆˆ" }, { mainCode: 'S', char: "åˆ€", code: "SH", hint: "å°¸ç«¹" },

            // T - å»¿
            { mainCode: 'T', char: "æ˜”", code: "TA", hint: "å»¿æ—¥" }, { mainCode: 'T', char: "æ›¹", code: "TWA", hint: "å»¿ç”°æ—¥" },
            { mainCode: 'T', char: "è‘—", code: "TJKA", hint: "å»¿åå¤§æ—¥" }, { mainCode: 'T', char: "é–‹", code: "ANT", hint: "æ—¥å¼“å»¿" }, 
            { mainCode: 'T', char: "æœŸ", code: "TCMC", hint: "å»¿é‡‘ä¸€é‡‘" }, { mainCode: 'T', char: "å…±", code: "TC", hint: "å»¿é‡‘" },
            { mainCode: 'T', char: "é»ƒ", code: "TWC", hint: "å»¿ç”°é‡‘" },

            // U - å±±
            { mainCode: 'U', char: "å‡±", code: "UMTU", hint: "å±±ä¸€å»¿å±±" }, { mainCode: 'U', char: "é€†", code: "YTU", hint: "åœå»¿å±±" }, 
            { mainCode: 'U', char: "å‡¶", code: "UK", hint: "å±±å¤§" }, { mainCode: 'U', char: "å³¨", code: "UHQI", hint: "å±±ç«¹æ‰‹æˆˆ" },
            { mainCode: 'U', char: "å´©", code: "UBB", hint: "å±±æœˆæœˆ" }, { mainCode: 'U', char: "å‡¹", code: "SSU", hint: "å°¸å°¸å±±" }, 

            // V - å¥³
            { mainCode: 'V', char: "åªš", code: "VAHU", hint: "å¥³æ—¥ç«¹å±±" }, { mainCode: 'V', char: "ç¶¿", code: "VHAB", hint: "å¥³ç«¹æ—¥æœˆ" },
            { mainCode: 'V', char: "å§", code: "VBBT", hint: "å¥³æœˆæœˆå»¿" }, { mainCode: 'V', char: "å«»", code: "VWD", hint: "å¥³æœ¨" }, 
            { mainCode: 'V', char: "çµ", code: "VYCK", hint: "å¥³åœé‡‘å¤§" },

            // W - ç”°
            { mainCode: 'W', char: "ç–Š", code: "WMBBM", hint: "ç”°ä¸€æœˆä¸€" }, { mainCode: 'W', char: "åœ", code: "WDMQ", hint: "ç”°æœ¨ä¸€æ‰‹" },
            { mainCode: 'W', char: "æœ", code: "WD", hint: "ç”°æœ¨" }, { mainCode: 'W', char: "é»˜", code: "WFIK", hint: "ç”°ç«æˆˆå¤§" },
            { mainCode: 'W', char: "åœˆ", code: "WFQU", hint: "ç”°ç«æ‰‹å±±" }, { mainCode: 'W', char: "åœ‹", code: "WIRM", hint: "ç”°æˆˆå£ä¸€" },

            // Y - åœ
            { mainCode: 'Y', char: "é€€", code: "YAV", hint: "åœæ—¥å¥³" }, { mainCode: 'Y', char: "è¿«", code: "YHA", hint: "åœç«¹æ—¥" },
            { mainCode: 'Y', char: "æ¡Œ", code: "YD", hint: "åœæœ¨" }, { mainCode: 'Y', char: "å¸", code: "YBJB", hint: "åœæœˆåæœˆ" },
            { mainCode: 'Y', char: "æœ›", code: "YBMG", hint: "åœæœˆä¸€åœŸ" }, 

            // X - é›£
            { mainCode: 'X', char: "è‡¼", code: "HX", hint: "ç«¹é›£" }, { mainCode: 'X', char: "ç¨»", code: "HDBX", hint: "ç«¹æœ¨æœˆé›£" }, 
            { mainCode: 'X', char: "èˆ‚", code: "QKX", hint: "æ‰‹å¤§é›£" }, { mainCode: 'X', char: "æ’", code: "QHJX", hint: "æ‰‹ç«¹åé›£" },
            { mainCode: 'X', char: "èˆŠ", code: "TOHX", hint: "å»¿äººç«¹é›£" }, { mainCode: 'X', char: "é½Š", code: "YX", hint: "åœé›£" }, 
        ];

        // Decoy generator
        const generateDecoys = (targetQ) => {
            const all = QUESTIONS.filter(q => q.code && q.code !== targetQ.code);
            return all.sort(() => Math.random() - 0.5).slice(0, 3).map(q => ({
                char: q.char,
                code: q.code
            }));
        };

        const META_UPGRADES = {
            hp: { name: "ç”Ÿå‘½ä¹‹æº", baseCost: 100, costMult: 1.5, effectVal: 10, icon: Heart, desc: "åˆå§‹ HP +10" },
            atk: { name: "åŠ›é‡å–šé†’", baseCost: 150, costMult: 1.6, effectVal: 2, icon: Sword, desc: "åˆå§‹æ”»æ“Š +2" },
            exp: { name: "æ™ºæ…§å…‰ç’°", baseCost: 200, costMult: 1.8, effectVal: 0.1, icon: BookOpen, desc: "ç¶“é©—ç²å– +10%" },
        };

        const RPG_ARTIFACTS = [
            { id: 'wand_1', name: 'å­¸å¾’æ³•æ–', type: 'weapon', val: 5, tier: 1, cost: 50, icon: Zap, desc: 'æ”»æ“ŠåŠ› +5', unlockCost: 0, effect: (p) => ({ ...p, atk: p.atk + 5 }) },
            { id: 'robe_1', name: 'å¸ƒè¡£', type: 'armor', val: 20, tier: 1, cost: 50, icon: Shield, desc: 'æœ€å¤§ HP +20', unlockCost: 0, effect: (p) => ({ ...p, maxHp: p.maxHp + 20, hp: p.hp + 20 }) },
            { id: 'ring_1', name: 'åŠ›é‡æˆ’æŒ‡', type: 'accessory', val: 5, tier: 1, cost: 60, icon: Star, desc: 'æ”»æ“ŠåŠ› +5', unlockCost: 0, effect: (p) => ({ ...p, atk: p.atk + 5 }) },
            { id: 'boots_1', name: 'è¼•éˆä¹‹é´', type: 'accessory', val: 0.05, tier: 1, cost: 60, icon: Wind, desc: 'é–ƒé¿ç‡ +5%', unlockCost: 0, effect: (p) => ({ ...p, dodge: p.dodge + 0.05 }) },
            { id: 'vamp_tooth', name: 'å¸è¡€é¬¼ä¹‹ç‰™', type: 'special', val: 0.1, tier: 2, cost: 150, icon: Droplets, desc: 'å¸è¡€ +10%', unlockCost: 500, effect: (p) => ({ ...p, lifesteal: p.lifesteal + 0.1 }) },
            { id: 'sharp_stone', name: 'é›·ç¥ç£¨åˆ€çŸ³', type: 'special', val: 0.15, tier: 2, cost: 150, icon: Zap, desc: 'æš´æ“Šç‡ +15%', unlockCost: 400, effect: (p) => ({ ...p, critChance: p.critChance + 0.15 }) },
            { id: 'spike_shield', name: 'èŠæ£˜ç›¾ç‰Œ', type: 'special', val: 0.2, tier: 2, cost: 180, icon: Shield, desc: 'åå‚· +20%', unlockCost: 450, effect: (p) => ({ ...p, thorns: p.thorns + 0.2, maxHp: p.maxHp + 20 }) },
            { id: 'hourglass', name: 'æ™‚å…‰æ²™æ¼', type: 'special', val: 1, tier: 2, cost: 200, icon: Timer, desc: 'æŠ€èƒ½å†·å» -1', unlockCost: 600, effect: (p) => ({ ...p, cdr: p.cdr + 1 }) },
            { id: 'heavy_plate', name: 'é‡å‹æ¿ç”²', type: 'armor', val: 50, tier: 2, cost: 120, icon: Shield, desc: 'æœ€å¤§ HP +50, é–ƒé¿ -5%', unlockCost: 300, effect: (p) => ({ ...p, maxHp: p.maxHp + 50, hp: p.hp + 50, dodge: Math.max(0, p.dodge - 0.05) }) },
            { id: 'swift_feather', name: 'ç–¾é¢¨ä¹‹ç¾½', type: 'accessory', val: 0.1, tier: 2, cost: 140, icon: Wind, desc: 'é–ƒé¿ç‡ +10%', unlockCost: 350, effect: (p) => ({ ...p, dodge: p.dodge + 0.1 }) },
            { id: 'cursed_mask', name: 'è©›å’’é¢å…·', type: 'special', val: 0, tier: 3, cost: 300, icon: Skull, desc: 'æ”»æ“Š +50%, HP -20% (ç‹‚æˆ°æµ)', unlockCost: 1000, effect: (p) => ({ ...p, atk: Math.floor(p.atk * 1.5), maxHp: Math.floor(p.maxHp * 0.8), hp: Math.min(p.hp, Math.floor(p.maxHp * 0.8)) }) },
            { id: 'titan_core', name: 'æ³°å¦æ ¸å¿ƒ', type: 'special', val: 0, tier: 3, cost: 350, icon: Shield, desc: 'è­·ç›¾è½‰åŒ–ç‚ºæ”»æ“ŠåŠ› (å¦å…‹æµ)', unlockCost: 1200, effect: (p) => ({ ...p, shieldToAtk: true, desc: 'è­·ç›¾åŠ æˆæ”»æ“Š' }) },
            { id: 'greedy_pot', name: 'è²ªå©ªä¹‹å£º', type: 'special', val: 0, tier: 3, cost: 250, icon: Coins, desc: 'æ¯æ¬¡æˆ°é¬¥å¤šé¸ä¸€å€‹çå‹µ (å¹¸é‹æµ)', unlockCost: 800, effect: (p) => ({ ...p, extraReward: true }) },
            { id: 'infinity_edge', name: 'ç„¡ç›¡ä¹‹åˆƒ', type: 'weapon', val: 0, tier: 3, cost: 400, icon: Sword, desc: 'æš´æ“Šå‚·å®³ +100% (çˆ†æ“Šæµ)', unlockCost: 1500, effect: (p) => ({ ...p, critMult: p.critMult + 1.0 }) },
            { id: 'phoenix_ash', name: 'é³³å‡°ç°ç‡¼', type: 'special', val: 0, tier: 3, cost: 500, icon: Flame, desc: 'æ­»äº¡æ™‚å¾©æ´»ä¸€æ¬¡ (ä¸€æ¬¡æ€§)', unlockCost: 2000, effect: (p) => ({ ...p, revive: true }) },
        ];

        const RPG_SKILLS = [
            { id: 'heal', name: 'æ²»ç™’è¡“', baseCd: 4, currentCd: 0, icon: Heart, color: 'bg-green-500', effect: (p) => ({ ...p, hp: Math.min(p.maxHp, p.hp + Math.floor(p.maxHp * 0.3)), log: `æ–½æ”¾æ²»ç™’è¡“ï¼å›å¾© ${Math.floor(p.maxHp * 0.3)} HP` }) },
            { id: 'burst', name: 'çˆ†è£‚é­”æ³•', baseCd: 6, currentCd: 0, icon: Flame, color: 'bg-red-500', effect: (p) => ({ ...p, bonusDmg: p.atk * 2, log: 'çˆ†è£‚é­”æ³•è“„åŠ›ï¼ä¸‹æ“Šå‚·å®³ 200%ï¼' }) },
            { id: 'guard', name: 'éµå£', baseCd: 5, currentCd: 0, icon: Shield, color: 'bg-blue-500', effect: (p) => ({ ...p, shield: 50, log: 'ç²å¾— 50 é»è­·ç›¾ï¼' }) },
        ];

        // --- ğŸ›ï¸ Meta Shop Component ---
        const MetaShop = ({ metaState, setMetaState, onBack }) => {
            const buyUpgrade = (type) => {
                const cfg = META_UPGRADES[type];
                const currentLv = metaState.upgrades[type];
                const cost = Math.floor(cfg.baseCost * Math.pow(cfg.costMult, currentLv));
                if (metaState.coins >= cost) {
                    AudioEngine.coin();
                    setMetaState(prev => ({ ...prev, coins: prev.coins - cost, upgrades: { ...prev.upgrades, [type]: currentLv + 1 } }));
                } else AudioEngine.wrong();
            };

            const unlockArtifact = (artId, cost) => {
                if (metaState.coins >= cost) {
                    AudioEngine.coin();
                    setMetaState(prev => ({ ...prev, coins: prev.coins - cost, unlockedArtifacts: [...prev.unlockedArtifacts, artId] }));
                } else AudioEngine.wrong();
            };

            return (
                <div className="h-full bg-slate-900 text-white p-6 overflow-y-auto">
                    <div className="flex justify-between items-center mb-8 sticky top-0 bg-slate-900/95 p-4 z-10 border-b border-slate-700">
                        <div className="flex items-center gap-4"><button onClick={onBack} className="bg-slate-700 p-2 rounded-full hover:bg-slate-600"><LucideIcon icon={ArrowLeft} /></button><h2 className="text-2xl font-bold text-magic-300">çŸ¥è­˜è–æ®¿</h2></div>
                        <div className="flex items-center gap-2 bg-slate-800 px-4 py-2 rounded-full border border-gold-500/50"><LucideIcon icon={Coins} className="text-gold-400" /><span className="font-bold text-xl text-gold-400">{metaState.coins}</span></div>
                    </div>
                    <div className="max-w-5xl mx-auto space-y-12">
                        <section><h3 className="text-xl font-bold mb-4 flex items-center gap-2 text-magic-100"><LucideIcon icon={GraduationCap} /> åŸºç¤èƒ½åŠ›å¼·åŒ–</h3><div className="grid grid-cols-1 md:grid-cols-3 gap-6">{Object.entries(META_UPGRADES).map(([key, cfg]) => { const lv = metaState.upgrades[key]; const cost = Math.floor(cfg.baseCost * Math.pow(cfg.costMult, lv)); const canAfford = metaState.coins >= cost; return ( <div key={key} className="bg-slate-800 p-6 rounded-2xl border border-slate-700 relative overflow-hidden"><div className="flex items-center gap-4 mb-4"><div className="p-3 bg-magic-900 rounded-lg"><LucideIcon icon={cfg.icon} size={28} className="text-magic-300" /></div><div><div className="font-bold text-lg">{cfg.name}</div><div className="text-xs text-slate-400">Lv.{lv}</div></div></div><p className="text-sm text-slate-300 mb-6">{cfg.desc} (ç•¶å‰: +{Math.round(cfg.effectVal * lv * 10)/10}{key === 'exp' ? '%' : ''})</p><button onClick={() => buyUpgrade(key)} disabled={!canAfford} className={`w-full py-2 rounded-xl font-bold flex items-center justify-center gap-2 ${canAfford ? 'bg-gold-600 hover:bg-gold-500 text-white' : 'bg-slate-700 text-slate-500 cursor-not-allowed'}`}><span>å‡ç´š</span><span className="text-xs bg-black/20 px-2 py-0.5 rounded flex items-center"><LucideIcon icon={Coins} size={12} className="mr-1"/>{cost}</span></button></div> ); })}</div></section>
                        <section><h3 className="text-xl font-bold mb-4 flex items-center gap-2 text-magic-100"><LucideIcon icon={Lock} /> éºç‰©è§£é–</h3><div className="grid grid-cols-1 md:grid-cols-4 gap-4">{RPG_ARTIFACTS.filter(a => a.unlockCost > 0).map(art => { const isUnlocked = metaState.unlockedArtifacts.includes(art.id); const canAfford = metaState.coins >= art.unlockCost; return ( <div key={art.id} className={`p-4 rounded-xl border-2 flex flex-col items-center text-center transition-all ${isUnlocked ? 'bg-magic-900/30 border-magic-500/50' : 'bg-slate-800 border-slate-700'}`}><div className={`p-3 rounded-full mb-2 ${isUnlocked ? 'bg-magic-500/20' : 'bg-slate-900'}`}><LucideIcon icon={art.icon} className={isUnlocked ? 'text-magic-300' : 'text-slate-600'} /></div><h4 className={`font-bold ${isUnlocked ? 'text-white' : 'text-slate-500'}`}>{art.name}</h4><p className="text-xs text-slate-400 mb-4 h-8">{art.desc}</p>{isUnlocked ? ( <div className="text-green-400 text-xs font-bold flex items-center"><LucideIcon icon={CheckCircle} size={12} className="mr-1"/> å·²è§£é–</div> ) : ( <button onClick={() => unlockArtifact(art.id, art.unlockCost)} disabled={!canAfford} className={`px-4 py-1 rounded-lg text-xs font-bold flex items-center ${canAfford ? 'bg-gold-600 text-white hover:bg-gold-500' : 'bg-slate-700 text-slate-500'}`}><LucideIcon icon={Unlock} size={10} className="mr-1"/> {art.unlockCost}</button> )}</div> ); })}</div></section>
                    </div>
                </div>
            );
        };

        // --- âš™ï¸ Game Setup Component ---
        const GameSetup = ({ onStart, onBack, mode }) => {
            const [inputMode, setInputMode] = useState('radical'); 
            const [difficulty, setDifficulty] = useState('normal'); 

            const inputModes = [
                { id: 'radical', name: 'å­—æ ¹ç·´ç¿’', desc: 'è¼¸å…¥é¦–ç¢¼ï¼Œé©åˆæ–°æ‰‹', icon: LayoutGrid },
                { id: 'quick', name: 'é€Ÿæˆ (é¦–å°¾)', desc: 'è¼¸å…¥é¦–å°¾ç¢¼ï¼Œåæ‡‰è¨“ç·´', icon: Zap },
                { id: 'cangjie', name: 'å€‰é ¡ (å…¨ç¢¼)', desc: 'è¼¸å…¥å®Œæ•´ç¢¼ï¼Œç¡¬æ´¾æŒ‘æˆ°', icon: Keyboard },
            ];

            const difficulties = [
                { id: 'easy', name: 'ä¼‘é–’', desc: 'æ€ªç‰©é€Ÿåº¦æ…¢ï¼Œå‚·å®³ä½', icon: Coffee, color: 'text-green-400' },
                { id: 'normal', name: 'æ™®é€š', desc: 'æ¨™æº–æŒ‘æˆ°', icon: Sword, color: 'text-yellow-400' },
                { id: 'hard', name: 'å›°é›£', desc: 'æ¥µé€Ÿåæ‡‰ï¼Œé«˜å‚·å®³', icon: Skull, color: 'text-red-500' },
            ];

            return (
                <div className="h-full bg-slate-950 p-6 flex flex-col items-center justify-center text-white">
                    <div className="w-full max-w-2xl">
                        <div className="flex items-center mb-8">
                            <button onClick={onBack} className="p-2 bg-slate-800 rounded-full hover:bg-slate-700 mr-4"><LucideIcon icon={ArrowLeft} /></button>
                            <h2 className="text-3xl font-bold flex items-center gap-2"><LucideIcon icon={Settings} /> éŠæˆ²è¨­å®š</h2>
                        </div>
                        
                        <div className="mb-8">
                            <h3 className="text-xl font-bold mb-4 text-magic-300">1. é¸æ“‡è¼¸å…¥æ¨¡å¼</h3>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                {inputModes.map(m => (
                                    <button key={m.id} onClick={() => setInputMode(m.id)} className={`p-4 rounded-xl border-2 text-left transition-all ${inputMode === m.id ? 'bg-magic-900 border-magic-500 ring-2 ring-magic-500/50' : 'bg-slate-800 border-slate-700 hover:bg-slate-700'}`}>
                                        <div className={`mb-2 ${inputMode === m.id ? 'text-magic-300' : 'text-slate-400'}`}><LucideIcon icon={m.icon} size={32}/></div>
                                        <div className="font-bold text-lg">{m.name}</div>
                                        <div className="text-xs text-slate-400">{m.desc}</div>
                                    </button>
                                ))}
                            </div>
                        </div>

                        <div className="mb-10">
                            <h3 className="text-xl font-bold mb-4 text-magic-300">2. é¸æ“‡é›£åº¦</h3>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                {difficulties.map(d => (
                                    <button key={d.id} onClick={() => setDifficulty(d.id)} className={`p-4 rounded-xl border-2 text-left transition-all ${difficulty === d.id ? 'bg-slate-800 border-white ring-2 ring-white/20' : 'bg-slate-900 border-slate-800 hover:bg-slate-800'}`}>
                                        <div className={`mb-2 ${d.color}`}><LucideIcon icon={d.icon} size={32}/></div>
                                        <div className="font-bold text-lg">{d.name}</div>
                                        <div className="text-xs text-slate-400">{d.desc}</div>
                                    </button>
                                ))}
                            </div>
                        </div>

                        <button onClick={() => onStart(inputMode, difficulty)} className="w-full py-4 bg-brand-600 hover:bg-brand-500 rounded-xl font-bold text-xl shadow-lg flex items-center justify-center gap-2 animate-pulse">
                            <span>ä¸‹ä¸€æ­¥ï¼šé¸æ“‡ç« ç¯€</span> <LucideIcon icon={ArrowLeft} className="rotate-180" />
                        </button>
                    </div>
                </div>
            );
        };

        // --- âš”ï¸ RPG Game Component ---
        const RPGGame = ({ inputMode, difficulty, chapter, onExit, onHome, initialData, metaState, onGameEnd }) => {
            const baseStats = {
                hp: 100 + (metaState.upgrades.hp * META_UPGRADES.hp.effectVal),
                atk: 20 + (metaState.upgrades.atk * META_UPGRADES.atk.effectVal),
                expMult: 1 + (metaState.upgrades.exp * META_UPGRADES.exp.effectVal)
            };

            const [player, setPlayer] = useState(initialData?.player || {
                hp: baseStats.hp, maxHp: baseStats.hp, atk: baseStats.atk, level: 1, exp: 0, maxExp: 100,
                critChance: 0.1, critMult: 1.5, lifesteal: 0, thorns: 0, dodge: 0, shield: 0, cdr: 0,
                bonusDmg: 0, combo: 0, floor: 1, gold: 0, 
                skills: RPG_SKILLS.map(s => ({...s, currentCd: 0})),
                artifacts: [], coinsGained: 0, revive: false, extraReward: false
            });
            
            const [monster, setMonster] = useState({ hp: 100, maxHp: 100, name: 'äº‚ç¢¼æ€ªç¸', type: MONSTER_TYPES[0] });
            const [attackGauge, setAttackGauge] = useState(0); 
            const [qIndex, setQIndex] = useState(0);
            const [turn, setTurn] = useState('player'); 
            const [userInput, setUserInput] = useState([]);
            const [combatLog, setCombatLog] = useState("æˆ°é¬¥é–‹å§‹ï¼");
            const [animation, setAnimation] = useState(null); 
            const [rewards, setRewards] = useState([]); 
            const [shopItems, setShopItems] = useState([]);
            const [showStats, setShowStats] = useState(false);

            const filteredQuestions = useMemo(() => chapter ? QUESTIONS.filter(q => q.mainCode === chapter) : QUESTIONS, [chapter]);
            const activeQuestions = filteredQuestions.length > 0 ? filteredQuestions : QUESTIONS;
            const currentQ = useMemo(() => activeQuestions[Math.floor(Math.random() * activeQuestions.length)], [qIndex, activeQuestions]);

            // Memoized silenced skill index for current monster
            const silencedSkillIdx = useMemo(() => {
                if (monster.type.effect === 'silence') return Math.floor(Math.random() * player.skills.length);
                return -1;
            }, [monster]);

            // Options for Radical Mode (Shuffled if confusion)
            const currentOptions = useMemo(() => {
                if (inputMode !== 'radical') return [];
                const correctOption = { label: `${KEYBOARD_MAP[currentQ.code[0]]} (${currentQ.code[0]})`, val: currentQ.code[0], isCorrect: true };
                const decoys = generateDecoys(currentQ).slice(0, 2).map(d => ({
                    label: `${KEYBOARD_MAP[d.code[0]] || '?'} (${d.code[0]})`, 
                    val: d.code[0], 
                    isCorrect: false 
                }));
                // Confusion Effect: Hide the Helper Text if confused
                const isConfused = monster.type.effect === 'confusion';
                const options = [correctOption, ...decoys].sort(() => Math.random() - 0.5);
                
                if (isConfused) {
                    return options.map(o => ({
                        ...o,
                        label: o.val // Show only 'A', 'B' etc. instead of 'æ—¥ (A)'
                    }));
                }
                return options;
            }, [qIndex, inputMode, currentQ, monster]);

            useEffect(() => { if (!initialData) spawnMonster(); }, []);

            const spawnMonster = () => {
                const isBoss = player.floor % 5 === 0;
                const pool = MONSTER_TYPES.filter(m => isBoss ? m.isBoss : !m.isBoss);
                const type = pool[Math.floor(Math.random() * pool.length)];
                
                let diffMod = 1.0;
                if (difficulty === 'easy') diffMod = 0.8;
                if (difficulty === 'hard') diffMod = 1.5;

                const scale = 1 + (player.floor * 0.25 * diffMod); 
                const hp = Math.floor(100 * type.hpMod * scale);
                const name = `${isBoss ? 'ã€BOSSã€‘' : ''}${type.name} (F${player.floor})`;
                setMonster({ hp, maxHp: hp, name, type });
                setAttackGauge(0);
                
                let log = `F${player.floor}: é­é‡ ${name}ï¼`;
                if (type.effect) log += ` (ç‰¹æ€§: ${type.effectName})`;
                setCombatLog(log);
            };

            const saveGame = () => {
                const data = JSON.stringify({ player, inputMode, difficulty, date: new Date().toISOString() });
                const blob = new Blob([data], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `word_battler_f${player.floor}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                setCombatLog("é€²åº¦å·²å„²å­˜ï¼");
            };
            
            const handleGameOver = (isWin) => {
                setTurn(isWin ? 'win' : 'lose');
                if (!isWin) AudioEngine.lose(); else AudioEngine.win();
            };

            useEffect(() => {
                let interval;
                if (turn === 'player') {
                    interval = setInterval(() => {
                        setAttackGauge(prev => {
                            if (prev >= 100) {
                                let dmgMult = 1.0;
                                if (difficulty === 'easy') dmgMult = 0.7;
                                if (difficulty === 'hard') dmgMult = 1.5;
                                
                                const baseDmg = 10 + (player.floor * 2);
                                const finalDmg = Math.floor(baseDmg * monster.type.atkMod * dmgMult);
                                handlePlayerDamage(finalDmg, `${monster.type.name} æ”»æ“Šï¼`);
                                return 0;
                            }
                            let speedMult = 1.0;
                            if (difficulty === 'easy') speedMult = 0.6;
                            if (difficulty === 'hard') speedMult = 1.4;

                            let inc = 2.5 * monster.type.speedMod * speedMult;
                            return prev + inc;
                        });
                    }, 200);
                }
                return () => clearInterval(interval);
            }, [turn, difficulty, monster, player.floor]);

            const handlePlayerDamage = (rawDmg, reason) => {
                if (Math.random() < player.dodge) { setCombatLog(`${reason} MISS!`); return; }
                AudioEngine.hit();
                setAnimation('damage');
                let damage = Math.max(0, rawDmg - player.shield);
                const remainingShield = Math.max(0, player.shield - rawDmg);
                if (player.thorns > 0) { const thornsDmg = Math.floor(rawDmg * player.thorns); setMonster(m => ({ ...m, hp: Math.max(0, m.hp - thornsDmg) })); }
                setPlayer(p => ({ ...p, hp: Math.max(0, p.hp - damage), shield: remainingShield, combo: 0 }));
                setCombatLog(`${reason} å—åˆ° ${damage} å‚·å®³ï¼`);
                setTimeout(() => { setAnimation(null); if (player.hp - damage <= 0) { if (player.revive) { setPlayer(p => ({ ...p, hp: p.maxHp, revive: false })); setCombatLog("é³³å‡°ç°ç‡¼è§¸ç™¼ï¼"); setAnimation('heal'); } else handleGameOver(false); } }, 300);
            };

            const resolvePlayerAttack = () => {
                const comboMult = 1 + (player.combo * 0.1);
                let atkVal = player.atk;
                if (player.shieldToAtk && player.shield > 0) atkVal += Math.floor(player.shield * 0.5);
                let damage = (atkVal + player.bonusDmg) * comboMult;
                let isCrit = Math.random() < player.critChance;
                if (isCrit) { damage *= player.critMult; AudioEngine.crit(); } else AudioEngine.attack();
                damage = Math.floor(damage);
                if (player.lifesteal > 0) setPlayer(p => ({ ...p, hp: Math.min(p.maxHp, p.hp + Math.floor(damage * player.lifesteal)) }));
                
                // Combo Logic
                const newCombo = player.combo + 1;
                let comboLog = `${isCrit ? 'æœƒå¿ƒï¼' : 'å‘½ä¸­ï¼'} -${damage}`;
                
                // Combo Bonus Check
                let bonusHeal = 0;
                let bonusShield = 0;
                if (newCombo > 0 && newCombo % 10 === 0) {
                    bonusHeal = Math.floor(player.maxHp * 0.05);
                    bonusShield = 10;
                    AudioEngine.powerUp(); // Sound effect for combo bonus
                    comboLog = `é€£æ“Šçå‹µï¼+${bonusHeal}HP +${bonusShield}ç›¾`;
                }

                setPlayer(p => ({ 
                    ...p, 
                    bonusDmg: 0, 
                    combo: newCombo, 
                    hp: Math.min(p.maxHp, p.hp + bonusHeal),
                    shield: p.shield + bonusShield,
                    skills: p.skills.map(s => ({ ...s, currentCd: Math.max(0, s.currentCd - 1) })) 
                })); 
                setMonster(m => ({ ...m, hp: Math.max(0, m.hp - damage) }));
                setCombatLog(comboLog);
                setAttackGauge(prev => Math.max(0, prev - 10));
                if (monster.hp - damage <= 0) setTimeout(handleMonsterDefeat, 600); else setTimeout(() => setUserInput([]), 600);
            };

            const handleSkill = (skillId) => {
                if (turn !== 'player') return;
                const idx = player.skills.findIndex(s => s.id === skillId);
                const skill = player.skills[idx];
                if (skill.currentCd > 0) return;
                AudioEngine.skill();
                const updatedSkills = [...player.skills];
                const cooldown = Math.max(1, skill.baseCd - player.cdr);
                updatedSkills[idx] = { ...skill, currentCd: cooldown };
                let newP = { ...player, skills: updatedSkills };
                let log = '';
                if (skill.id === 'heal') { const v = Math.floor(newP.maxHp * 0.3); newP.hp = Math.min(newP.maxHp, newP.hp + v); log = `å›å¾© ${v} HP`; }
                else if (skill.id === 'burst') { newP.bonusDmg = newP.atk * 2; log = 'ä¸‹æ“Šå‚·å®³ 200%'; }
                else if (skill.id === 'guard') { newP.shield += 50; log = 'è­·ç›¾ +50'; }
                setPlayer(newP); setCombatLog(log); setAnimation('heal'); setTimeout(() => setAnimation(null), 800);
            };

            const handleMonsterDefeat = () => {
                AudioEngine.levelUp();
                const expGain = Math.floor((50 + (player.floor * 10)) * baseStats.expMult);
                const coinGain = 15 + Math.floor(player.floor * 3);
                let newExp = player.exp + expGain;
                let newLevel = player.level;
                let newMaxExp = player.maxExp;
                let leveledUp = false;
                if (newExp >= player.maxExp) { newExp -= player.maxExp; newLevel++; newMaxExp = Math.floor(newMaxExp * 1.2); leveledUp = true; }
                setPlayer(p => ({ ...p, exp: newExp, level: newLevel, maxExp: newMaxExp, maxHp: leveledUp ? p.maxHp + 10 : p.maxHp, atk: leveledUp ? p.atk + 2 : p.atk, hp: leveledUp ? p.maxHp : p.hp, floor: p.floor + 1, coinsGained: p.coinsGained + coinGain, gold: p.gold + coinGain }));
                const numChoices = player.extraReward ? 6 : 5;
                const availableArtifacts = RPG_ARTIFACTS.filter(a => a.unlockCost === 0 || metaState.unlockedArtifacts.includes(a.id));
                const pool = availableArtifacts.sort(() => 0.5 - Math.random()).slice(0, numChoices);
                setRewards(pool);
                setTurn('reward');
            };

            const handleSelectReward = (reward) => {
                AudioEngine.correct();
                const newP = reward.effect(player);
                const safeArtifact = { id: reward.id, name: reward.name, icon: reward.icon, desc: reward.desc };
                setPlayer({ ...newP, artifacts: [...newP.artifacts, safeArtifact] });
                determineNextEvent();
            };

            const determineNextEvent = () => {
                const roll = Math.random();
                if (player.floor % 5 === 0) { 
                    const nextFloor = player.floor + 1;
                    setPlayer(p => ({...p, floor: nextFloor}));
                    if (nextFloor % 3 === 0) generateShop();
                    else if (roll < 0.2) setTurn('camp');
                    else nextBattle();
                } else {
                     const nextFloor = player.floor + 1;
                     setPlayer(p => ({...p, floor: nextFloor}));
                     if (roll < 0.1) generateShop();
                     else if (roll < 0.25) setTurn('camp');
                     else nextBattle();
                }
            };

            const nextBattle = () => {
                setQIndex(q => q + 1); spawnMonster(); setUserInput([]); setTurn('player');
            };

            const generateShop = () => {
                const shopPool = RPG_ARTIFACTS.filter(a => a.unlockCost === 0 || metaState.unlockedArtifacts.includes(a.id)).sort(() => 0.5 - Math.random()).slice(0, 3);
                setShopItems([
                    ...shopPool.map(i => ({ ...i, price: Math.floor(i.cost * (0.8 + Math.random()*0.4)) })),
                    { id: 'potion', name: 'å¤§ç´…è—¥æ°´', type: 'consumable', val: 100, price: 30, icon: Coffee, desc: 'å›å¾© 100 HP', effect: (p)=>({...p, hp: Math.min(p.maxHp, p.hp+100)}) }
                ]);
                setTurn('shop');
            };

            const handleShopBuy = (item) => {
                if (player.gold >= item.price) {
                    AudioEngine.coin();
                    const newP = item.effect(player);
                    if (item.type !== 'consumable') newP.artifacts = [...newP.artifacts, { id: item.id, name: item.name, icon: item.icon, desc: item.desc }];
                    setPlayer({ ...newP, gold: newP.gold - item.price });
                    setShopItems(prev => prev.filter(i => i !== item));
                } else AudioEngine.wrong();
            };

            const handleCampAction = (action) => {
                AudioEngine.heal();
                if (action === 'rest') {
                    setPlayer(p => ({ ...p, hp: Math.min(p.maxHp, p.hp + Math.floor(p.maxHp * 0.5)) }));
                    setCombatLog("ä¼‘æ¯äº†ä¸€æ™šï¼Œç²¾ç¥ç™¾å€ï¼");
                } else {
                    setPlayer(p => ({ ...p, maxHp: p.maxHp + 10, atk: p.atk + 2 }));
                    setCombatLog("ç¶“éé›éŠï¼Œè®Šå¾—æ›´å¼·äº†ï¼");
                }
                setTimeout(nextBattle, 1000);
            };

            // Enhanced Key Handling Logic based on Input Mode
            const handleKeyInput = (key) => {
                if (turn !== 'player') return;

                if (inputMode === 'radical') {
                    if (key === currentQ.code[0]) {
                        resolvePlayerAttack(); 
                    } else {
                        handlePlayerDamage(5, "æŒ‰éŒ¯äº†ï¼"); 
                    }
                } 
                else if (inputMode === 'quick') {
                    const targetCode = currentQ.code[0] + (currentQ.code.length > 1 ? currentQ.code[currentQ.code.length-1] : '');
                    const nextInput = [...userInput, key];
                    if (targetCode.startsWith(nextInput.join(''))) {
                        if (nextInput.join('') === targetCode) {
                            resolvePlayerAttack();
                            setUserInput([]);
                        } else {
                            AudioEngine.click();
                            setUserInput(nextInput);
                        }
                    } else {
                         handlePlayerDamage(5, "æŒ‰éŒ¯äº†ï¼");
                         setUserInput([]);
                    }
                }
                else if (inputMode === 'cangjie') {
                    const targetCode = currentQ.code;
                    const nextInput = [...userInput, key];
                    if (targetCode.startsWith(nextInput.join(''))) {
                        if (nextInput.join('') === targetCode) {
                            resolvePlayerAttack();
                            setUserInput([]);
                        } else {
                            AudioEngine.click();
                            setUserInput(nextInput);
                        }
                    } else {
                        handlePlayerDamage(5, "æŒ‰éŒ¯äº†ï¼");
                        setUserInput([]); 
                    }
                }
            };

            useEffect(() => {
                const handlePhysicalKey = (e) => {
                    const key = e.key.toUpperCase();
                    if (/^[A-Z]$/.test(key)) handleKeyInput(key);
                };
                window.addEventListener('keydown', handlePhysicalKey);
                return () => window.removeEventListener('keydown', handlePhysicalKey);
            }, [inputMode, turn, userInput, currentQ]);

            const handleOptionClick = (val) => {
                if (turn !== 'player') return;
                let isCorrect = (val === currentQ.code[0]);
                if (isCorrect) resolvePlayerAttack();
                else handlePlayerDamage(5, "é¸éŒ¯äº†ï¼");
            };

            const renderInput = () => {
                const isConfused = monster.type.effect === 'confusion';
                const isBlind = monster.type.effect === 'blind';

                if (inputMode === 'radical') {
                    return <div className="grid grid-cols-3 gap-4 max-w-2xl mx-auto">{currentOptions.map((o,i) => <button key={i} onClick={() => handleOptionClick(o.val)} className={`bg-slate-800 border-2 border-magic-600 py-6 rounded-xl text-xl font-bold text-magic-100 active:scale-95 hover:bg-slate-700 transition-all ${isConfused ? 'animate-wiggle' : ''}`}>{o.label}</button>)}</div>;
                }
                
                const keys = "QWERTYUIOPASDFGHJKLZXCVBNM".split('');
                return (
                    <div className="w-full max-w-3xl mx-auto p-2">
                        <div className="flex justify-center mb-4 space-x-2 min-h-[50px]">{userInput.map((k, i) => <div key={i} className={`w-12 h-12 border-2 rounded flex items-center justify-center text-2xl font-bold bg-slate-800 border-magic-500 text-magic-300 animate-float-up`}>{KEYBOARD_MAP[k]}</div>)}</div>
                        <div className="keyboard-grid">
                            {keys.map(k => (
                                <button key={k} onClick={() => handleKeyInput(k)} className={`aspect-square bg-slate-800 border border-slate-700 rounded flex flex-col items-center justify-center hover:bg-slate-700 active:bg-slate-600 transition-all ${isConfused ? 'animate-wiggle' : ''}`}>
                                    <span className="text-xs text-slate-500">{k}</span>
                                    {/* Confusion: Hide Key Map in Keyboard Mode. Blind: Also hide? User said "é®ä½é¡Œç›®çš„æç¤ºæˆ–å­—æ ¹". So hide map if blind or confused. */}
                                    <span className={`text-magic-300 font-bold ${isBlind || isConfused ? 'opacity-0' : 'opacity-100'}`}>{KEYBOARD_MAP[k]}</span>
                                </button>
                            ))}
                        </div>
                    </div>
                );
            };

            if (turn === 'lose') return <div className="absolute inset-0 bg-slate-950 flex flex-col items-center justify-center text-white p-8 z-50"><LucideIcon icon={Skull} size={80} className="text-red-500 mb-6" /><h2 className="text-4xl font-bold mb-2 text-red-500">æŒ‘æˆ°çµæŸ</h2><p className="text-xl mb-4">æ­¢æ­¥æ–¼ç¬¬ {player.floor} å±¤</p><div className="bg-slate-800 p-6 rounded-2xl mb-8 flex flex-col items-center border border-gold-500/30"><p className="text-sm text-gold-400 mb-2">æœ¬æ¬¡ç²å¾—</p><div className="flex items-center gap-2 text-3xl font-bold text-yellow-400"><LucideIcon icon={Coins} /> <span>{player.coinsGained + (player.floor * 5)}</span></div></div><button onClick={() => onGameEnd(player.coinsGained)} className="bg-slate-700 hover:bg-slate-600 px-8 py-3 rounded-full font-bold">è¿”å›è–æ®¿</button></div>;

            if (turn === 'shop') return (
                <div className="absolute inset-0 bg-slate-950 flex flex-col items-center justify-center text-white p-8 z-50">
                    <h2 className="text-3xl font-bold text-gold-400 mb-4 flex items-center gap-2"><LucideIcon icon={ShoppingBag}/> ç¥ç§˜å•†åº—</h2>
                    <p className="mb-6 text-slate-400">æŒæœ‰é‡‘å¹£: <span className="text-yellow-400 font-bold">{player.gold}</span></p>
                    <div className="grid grid-cols-1 md:grid-cols-4 gap-4 w-full max-w-5xl">
                        {shopItems.map((item, i) => (
                            <button key={i} onClick={() => handleShopBuy(item)} disabled={player.gold < item.price} className={`p-4 rounded-xl border-2 flex flex-col items-center transition-all ${player.gold >= item.price ? 'bg-slate-800 border-gold-600 hover:bg-slate-700' : 'bg-slate-900 border-slate-700 opacity-50'}`}>
                                <LucideIcon icon={item.icon} size={32} className="text-gold-400 mb-2" />
                                <h4 className="font-bold">{item.name}</h4>
                                <p className="text-xs text-slate-400 mb-2">{item.desc}</p>
                                <span className="text-yellow-400 font-bold flex items-center"><LucideIcon icon={Coins} size={12} className="mr-1"/> {item.price}</span>
                            </button>
                        ))}
                    </div>
                    <button onClick={nextBattle} className="mt-8 bg-brand-600 hover:bg-brand-500 px-8 py-3 rounded-full font-bold">é›¢é–‹å•†åº—</button>
                </div>
            );

            if (turn === 'camp') return (
                <div className="absolute inset-0 bg-slate-950 flex flex-col items-center justify-center text-white p-8 z-50">
                    <LucideIcon icon={Tent} size={80} className="text-green-500 mb-6" />
                    <h2 className="text-3xl font-bold mb-8">ä¼‘æ¯ç‡Ÿåœ°</h2>
                    <div className="flex gap-6">
                        <button onClick={() => handleCampAction('rest')} className="bg-slate-800 border-2 border-green-600 p-8 rounded-2xl hover:bg-slate-700 transition-all flex flex-col items-center w-48">
                            <LucideIcon icon={BedDouble} size={48} className="text-green-400 mb-4" />
                            <h3 className="text-xl font-bold">ä¼‘æ¯</h3>
                            <p className="text-sm text-slate-400 mt-2">å›å¾© 50% HP</p>
                        </button>
                        <button onClick={() => handleCampAction('train')} className="bg-slate-800 border-2 border-red-600 p-8 rounded-2xl hover:bg-slate-700 transition-all flex flex-col items-center w-48">
                            <LucideIcon icon={Dumbbell} size={48} className="text-red-400 mb-4" />
                            <h3 className="text-xl font-bold">é›éŠ</h3>
                            <p className="text-sm text-slate-400 mt-2">HP+10, ATK+2</p>
                        </button>
                    </div>
                </div>
            );

            if (turn === 'reward') return ( 
                <div className="absolute inset-0 bg-slate-900/95 flex flex-col items-center justify-center text-white p-4 z-50">
                    <h2 className="text-3xl font-bold text-yellow-400 mb-8 animate-bounce">æˆ°åˆ©å“é¸æ“‡</h2>
                    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4 max-w-6xl w-full">
                        {rewards.map((r, i) => (
                            <button key={i} onClick={() => handleSelectReward(r)} className="bg-slate-800 border-2 border-magic-600 hover:scale-105 transition-transform p-4 rounded-xl flex flex-col items-center shadow-xl group h-full">
                                <LucideIcon icon={r.icon} size={36} className="text-yellow-400 mb-3 group-hover:scale-110 transition-transform" />
                                <h3 className="text-lg font-bold mb-1 text-center leading-tight">{r.name}</h3>
                                <p className="text-xs text-slate-300 text-center flex-1 flex items-center justify-center">{r.desc}</p>
                            </button>
                        ))}
                    </div>
                </div> 
            );

            return (
                <div className={`h-full w-full flex flex-col bg-slate-950 text-white font-sans relative overflow-hidden ${animation === 'damage' ? 'animate-damage-flash' : ''}`}>
                    {/* Header */}
                    <div className="p-3 bg-slate-900/90 border-b border-slate-800 flex justify-between items-center z-10">
                        <div className="flex items-center gap-4 cursor-pointer hover:bg-slate-800/50 rounded-lg p-1" onClick={() => setShowStats(!showStats)}>
                            <div className="w-12 h-12 bg-magic-700 rounded-lg flex flex-col items-center justify-center border-2 border-magic-500 relative overflow-hidden">
                                <span className="text-xs relative z-10">LV</span><span className="font-bold text-xl relative z-10">{player.level}</span>
                                <div className="absolute bottom-0 w-full bg-yellow-500/30 transition-all duration-300" style={{height: `${(player.combo % 10) * 10}%`}}></div>
                            </div>
                            <div>
                                <div className="text-xs text-slate-400 flex justify-between w-32"><span>F{player.floor}</span><span className="text-yellow-400 font-bold">Combo {player.combo}</span></div>
                                <div className="w-32 h-3 bg-slate-800 rounded-full overflow-hidden relative"><div className="h-full bg-red-500 transition-all duration-300" style={{width: `${(player.hp/player.maxHp)*100}%`}}></div>{player.shield>0 && <div className="absolute top-0 h-full bg-blue-400/50" style={{width: `${(player.shield/player.maxHp)*100}%`}}/>}</div>
                                <div className="text-[10px] text-right">{player.hp}/{player.maxHp}</div>
                            </div>
                        </div>
                        <div className="flex items-center gap-4">
                            <div className="flex items-center gap-1 text-gold-400 font-bold bg-slate-800 px-3 py-1 rounded-full text-sm border border-slate-700"><LucideIcon icon={Coins} size={14}/> {player.gold}</div>
                            <button onClick={saveGame} className="p-2 bg-slate-800 rounded border border-slate-600"><LucideIcon icon={Save} size={18}/></button>
                            <button onClick={() => handleGameOver(false)} className="p-2 bg-red-900/50 text-red-400 rounded hover:bg-red-900"><LucideIcon icon={X} size={18}/></button>
                        </div>
                    </div>
                    {showStats && <div className="absolute top-20 left-4 bg-slate-900/95 border border-slate-700 p-4 rounded-xl z-40 text-sm shadow-xl min-w-[200px]" onClick={()=>setShowStats(false)}><h4 className="font-bold border-b border-slate-700 mb-2 pb-1 text-magic-300">å±¬æ€§</h4><p>âš”ï¸ {player.atk} | âš¡ {Math.round(player.critChance*100)}% | ğŸ©¸ {Math.round(player.lifesteal*100)}% | ğŸ’¨ {Math.round(player.dodge*100)}%</p><h4 className="font-bold border-b border-slate-700 mb-2 pb-1 mt-2 text-magic-300">éºç‰©</h4><div className="flex flex-wrap gap-1">{player.artifacts.map((a,i)=><div key={i} title={a.name} className="bg-slate-800 p-1.5 rounded border border-slate-600"><LucideIcon icon={a.icon} size={16} className="text-yellow-500"/></div>)}</div></div>}
                    <div className="flex-1 relative flex flex-col items-center justify-center">
                        <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-magic-900/30 to-slate-950 -z-10"></div>
                        <div className="absolute top-4 flex gap-4 z-20">
                            {player.skills.map((s, index) => {
                                const isSilenced = monster.type.effect === 'silence' && index === silencedSkillIdx;
                                return (
                                    <button key={s.id} onClick={() => handleSkill(s.id)} disabled={s.currentCd > 0 || isSilenced} className={`w-14 h-14 rounded-full border-2 flex items-center justify-center relative transition-transform active:scale-95 ${s.currentCd > 0 || isSilenced ? 'bg-slate-800 border-slate-600 opacity-50 cursor-not-allowed' : `${s.color} border-white shadow-lg`}`}>
                                        <LucideIcon icon={s.icon} size={24} className="text-white" />
                                        {s.currentCd > 0 && <div className="absolute inset-0 bg-black/60 rounded-full flex items-center justify-center font-bold text-white">{s.currentCd}</div>}
                                        {isSilenced && <div className="absolute inset-0 bg-black/80 rounded-full flex items-center justify-center text-red-500"><LucideIcon icon={MicOff} size={20} /></div>}
                                    </button>
                                );
                            })}
                        </div>
                        <motion.div animate={{ y: [0, -10, 0] }} transition={{ repeat: Infinity, duration: 3 }} className="relative z-10 mt-8 mb-4">
                            <div className="w-40 h-40 bg-slate-800 rounded-full border-4 border-magic-500 flex items-center justify-center shadow-[0_0_30px_rgba(139,92,246,0.4)] relative">
                                <LucideIcon icon={monster.type.icon} size={80} className={monster.type.color} />
                                <span className="absolute text-7xl font-serif font-black text-white drop-shadow-md">{currentQ.char}</span>
                                {monster.type.effect && <div className="absolute -top-2 -right-2 bg-red-600 text-white text-[10px] px-2 py-1 rounded-full font-bold shadow-sm z-20 flex items-center gap-1"><LucideIcon icon={monster.type.effect==='blind'?EyeOff : monster.type.effect==='silence'?MicOff : Shuffle} size={10}/> {monster.type.effectName}</div>}
                            </div>
                            <div className="absolute -bottom-6 left-1/2 transform -translate-x-1/2 w-32 h-2 bg-slate-800 rounded-full overflow-hidden border border-slate-600"><motion.div className="h-full bg-red-500" style={{ width: `${attackGauge}%` }} transition={{ ease: 'linear', duration: 0.2 }} /></div>
                            <div className="absolute -top-8 w-full text-center text-red-400 font-bold text-sm">{monster.name}</div>
                        </motion.div>
                        <div className="text-center h-8 font-bold text-lg text-magic-200">{combatLog}</div>
                    </div>
                    <div className="bg-slate-900 border-t border-slate-800 p-6 rounded-t-3xl shadow-2xl">
                         {/* Input Hints */}
                        <div className="text-center mb-4 text-slate-400 text-sm h-6">
                            {monster.type.effect === 'blind' ? <span className="text-red-400 flex items-center justify-center gap-1"><LucideIcon icon={EyeOff} size={14}/> æç¤ºå·²è¢«é®è”½</span> : (
                                <>
                                {inputMode === 'radical' && `é¸æ“‡å°æ‡‰å­—é¦– [${currentQ.code[0]}]`}
                                {inputMode === 'quick' && `è¼¸å…¥é¦–å°¾ç¢¼ (2ç¢¼) [${currentQ.code[0]}${currentQ.code.length > 1 ? currentQ.code.slice(-1) : ''}] - æç¤º: ${currentQ.hint}`}
                                {inputMode === 'cangjie' && `è¼¸å…¥å…¨ç¢¼ (${currentQ.code.length}ç¢¼) [${currentQ.code}] - æç¤º: ${currentQ.hint}`}
                                </>
                            )}
                        </div>
                        <div className="max-w-4xl mx-auto text-center">{renderInput()}</div>
                    </div>
                </div>
            );
        };

        // --- ğŸƒ Runner Game ---
        const RunnerGame = ({ inputMode, difficulty, chapter, onExit, onHome, currentTheme = THEMES.FOREST, user }) => {
            const [score, setScore] = useState(0);
            const [time, setTime] = useState(0);
            const [qIndex, setQIndex] = useState(0);
            const [gameState, setGameState] = useState('running');
            const [userInput, setUserInput] = useState([]);
            const [feedback, setFeedback] = useState(null);
            const [message, setMessage] = useState(null);
            const [qStartTime, setQStartTime] = useState(null);
            
            const filteredQuestions = useMemo(() => chapter ? QUESTIONS.filter(q => q.mainCode === chapter) : QUESTIONS, [chapter]);
            const activeQuestions = filteredQuestions.length > 0 ? filteredQuestions : QUESTIONS;
            const currentQ = useMemo(() => activeQuestions[Math.floor(Math.random() * activeQuestions.length)], [qIndex, activeQuestions]);
            
            const charProgress = (qIndex / 10) * 80;
            const charPosition = gameState === 'win' ? 90 : 10 + charProgress;

            useEffect(() => {
                let interval; if (gameState !== 'win') interval = setInterval(() => setTime(t => t + 1), 1000);
                return () => clearInterval(interval);
            }, [gameState]);

            useEffect(() => {
                let timer; if (gameState === 'running') timer = setTimeout(() => { setGameState('bullet_time'); setQStartTime(Date.now()); }, 2000);
                return () => clearTimeout(timer);
            }, [gameState, qIndex]);

            // Options for Radical Mode
            const currentOptions = useMemo(() => {
                if (inputMode !== 'radical') return [];
                const correct = { label: `${KEYBOARD_MAP[currentQ.code[0]]} (${currentQ.code[0]})`, val: currentQ.code[0], isCorrect: true };
                const decoys = generateDecoys(currentQ).slice(0, 2).map(d => ({ label: `${KEYBOARD_MAP[d.code[0]]} (${d.code[0]})`, val: d.code[0], isCorrect: false }));
                return [correct, ...decoys].sort(() => Math.random() - 0.5);
            }, [qIndex, inputMode, currentQ]);

            const handleOptionClick = (val) => {
                if (feedback === 'correct') return;
                let isCorrect = (val === currentQ.code[0]);
                if (isCorrect) processAnswer(true);
                else { AudioEngine.wrong(); setFeedback('wrong'); setMessage(`å†è©¦ä¸€æ¬¡ï¼`); setTimeout(() => { setFeedback(null); setMessage(null); }, 1000); }
            };
            
            const handleKeyInput = (key) => {
                if (gameState !== 'bullet_time' || feedback === 'correct') return;

                if (inputMode === 'radical') {
                    if (key === currentQ.code[0]) processAnswer(true);
                    else { AudioEngine.wrong(); setFeedback('wrong'); setMessage(`å†è©¦ä¸€æ¬¡ï¼`); setTimeout(() => { setFeedback(null); setMessage(null); }, 1000); }
                }
                else if (inputMode === 'quick') {
                    const target = currentQ.code[0] + (currentQ.code.length > 1 ? currentQ.code[currentQ.code.length-1] : '');
                    const nextInput = [...userInput, key];
                    
                    if (target.startsWith(nextInput.join(''))) {
                         if (nextInput.join('') === target) {
                             processAnswer(true);
                             setUserInput([]);
                         } else {
                             AudioEngine.click();
                             setUserInput(nextInput);
                         }
                    } else {
                        AudioEngine.wrong(); setFeedback('wrong'); setMessage(`æŒ‰éŒ¯äº†ï¼`); 
                        setUserInput([]);
                        setTimeout(() => { setFeedback(null); setMessage(null); }, 1000);
                    }
                }
                else if (inputMode === 'cangjie') {
                     const target = currentQ.code;
                     const nextInput = [...userInput, key];
                     
                     if (target.startsWith(nextInput.join(''))) {
                         if (nextInput.join('') === target) {
                             processAnswer(true);
                             setUserInput([]);
                         } else {
                             AudioEngine.click();
                             setUserInput(nextInput);
                         }
                     } else {
                        AudioEngine.wrong(); setFeedback('wrong'); setMessage(`æŒ‰éŒ¯äº†ï¼`); 
                        setUserInput([]);
                        setTimeout(() => { setFeedback(null); setMessage(null); }, 1000);
                     }
                }
            };

            useEffect(() => {
                const h = (e) => { const k = e.key.toUpperCase(); if (/^[A-Z]$/.test(k)) handleKeyInput(k); };
                window.addEventListener('keydown', h); return () => window.removeEventListener('keydown', h);
            }, [inputMode, gameState, userInput, feedback, currentQ]);

            const processAnswer = () => {
                AudioEngine.correct(); setFeedback('correct'); setMessage(null);
                const speedBonus = Math.max(0, Math.floor(50 - ((Date.now() - qStartTime)/1000) * 5));
                setScore(s => s + 100 + speedBonus);
                setTimeout(() => { setFeedback(null); setUserInput([]); setQIndex(q => q + 1); setGameState('running'); }, 1000);
            };

            const renderInput = () => {
                 if (inputMode === 'radical') {
                     return <div className="grid grid-cols-3 gap-4 w-full max-w-2xl mx-auto">{currentOptions.map((opt, i) => (<button key={i} onClick={() => handleOptionClick(opt.val)} className={`relative py-6 rounded-2xl text-xl font-bold shadow-lg transform transition-all active:scale-95 flex items-center justify-center overflow-hidden ${feedback === 'correct' && opt.isCorrect ? 'bg-green-500 text-white' : 'bg-white text-slate-800 hover:bg-brand-50'} ${feedback === 'wrong' && !opt.isCorrect ? 'opacity-50 bg-red-50' : ''}`}><span className={`absolute left-3 top-2 text-2xl font-black opacity-20 ${feedback === 'correct' && opt.isCorrect ? 'text-white' : 'text-slate-900'}`}>{String.fromCharCode(65 + i)}</span><span>{opt.label}</span></button>))}</div>;
                 }
                 const keys = "QWERTYUIOPASDFGHJKLZXCVBNM".split('');
                 return <div className="w-full max-w-3xl mx-auto p-2"><div className="flex justify-center mb-4 space-x-2 min-h-[50px]">{userInput.map((k,i) => <div key={i} className={`w-12 h-12 border-2 rounded flex items-center justify-center text-2xl font-bold transition-colors duration-300 bg-white border-brand-500 text-brand-600 animate-float-up`}>{KEYBOARD_MAP[k]}</div>)}</div><div className="keyboard-grid">{keys.map(k => (<button key={k} onClick={() => handleKeyInput(k)} className={`aspect-square rounded-md shadow-sm border flex flex-col items-center justify-center transition-colors ${userInput.length === 0 && userInput.includes(k) && feedback === 'wrong-first' ? 'bg-red-100 border-red-300' : 'bg-white border-slate-200 active:bg-brand-100'}`}><span className="text-xs font-bold text-slate-400">{k}</span><span className="text-lg font-bold font-serif text-slate-800">{KEYBOARD_MAP[k]}</span></button>))}</div></div>;
            };

            return (
                <div className={`h-full w-full flex flex-col ${currentTheme.bg} overflow-hidden relative`}>
                    <div className="absolute top-0 left-0 right-0 p-4 flex justify-between items-start z-30 pointer-events-none"><div className="flex items-center space-x-2 pointer-events-auto"><button onClick={onExit} className="bg-white/80 p-2 rounded-full shadow-md mr-2"><LucideIcon icon={ArrowLeft} size={20} /></button><div className="flex items-center space-x-2 bg-white/80 backdrop-blur px-3 py-1 rounded-full shadow-sm min-w-[80px]"><LucideIcon icon={Timer} className="text-blue-500 fill-current" size={18} /><span className="font-bold text-slate-800 font-mono">{Math.floor(time / 60).toString().padStart(2, '0')}:{ (time % 60).toString().padStart(2, '0') }</span></div><div className="flex items-center space-x-2 bg-white/80 backdrop-blur px-3 py-1 rounded-full shadow-sm"><LucideIcon icon={Star} className="text-yellow-500 fill-current" size={18} /><span className="font-bold text-slate-800">{score}</span></div></div><button onClick={onHome} className="bg-brand-500 text-white p-2 rounded-full shadow-md pointer-events-auto hover:bg-brand-600 transition-colors"><LucideIcon icon={Home} size={20} /></button></div>
                    <div className="relative h-[45%] flex flex-col justify-end overflow-hidden">
                        <div className="absolute top-10 right-10 text-slate-400/50"><LucideIcon icon={currentTheme.decor} size={64} /></div><div className="absolute top-20 left-10 text-slate-400/30"><LucideIcon icon={Cloud} size={48} /></div><div className={`absolute bottom-0 w-full h-1/2 bg-gradient-to-b ${currentTheme.road} perspective-road flex justify-center`}><div className={`w-4 h-full bg-white/30 ${gameState === 'running' ? 'animate-pulse' : ''}`}></div></div><div className="absolute bottom-10 right-[5%] z-10 flex flex-col items-center"><div className="h-24 w-2 bg-slate-400"></div><LucideIcon icon={Flag} size={48} className="text-red-500 fill-current" /></div><div className={`absolute bottom-4 w-full flex justify-between px-10 ${gameState === 'running' ? 'animate-run' : ''} opacity-50`}><LucideIcon icon={Trees} size={32} className="text-green-800" /><LucideIcon icon={Trees} size={32} className="text-green-800" /></div>
                        <div className="absolute bottom-8 z-20 transition-all duration-1000 ease-in-out" style={{ left: `${charPosition}%` }}><div className="relative transform -translate-x-1/2"><motion.div animate={gameState === 'running' ? { y: [0, -10, 0] } : { y: 0 }} transition={{ repeat: Infinity, duration: 0.5 }}><div style={{ transform: 'scaleX(-1)', display: 'inline-block' }} className={`text-6xl filter drop-shadow-2xl transition-all ${feedback === 'wrong' ? 'animate-shake grayscale' : ''}`}>{feedback === 'wrong' ? 'ğŸ˜µ' : 'ğŸƒ'}</div></motion.div><div className="w-16 h-4 bg-black/20 rounded-full mx-auto blur-sm mt-[-5px]"></div><AnimatePresence><motion.div key={qIndex} initial={{ scale: 0, y: 50, opacity: 0 }} animate={{ scale: gameState === 'bullet_time' ? 1 : 0.2, y: gameState === 'bullet_time' ? -100 : 20, opacity: gameState === 'bullet_time' ? 1 : 0 }} transition={{ type: 'spring', damping: 20 }} className="absolute bottom-0 left-1/2 transform -translate-x-1/2 z-30 mb-12"><div className={`bg-white border-8 border-slate-800 rounded-2xl w-32 h-32 flex flex-col items-center justify-center shadow-2xl relative ${gameState === 'running' ? 'animate-bounce' : ''}`}><span className="text-6xl font-serif font-black text-slate-900">{currentQ ? currentQ.char : '?'}</span>{gameState === 'bullet_time' && <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} className="w-full flex flex-col items-center"><h3 className={`font-bold mb-6 text-sm tracking-wider uppercase transition-colors duration-300 ${feedback?.includes('wrong') ? 'text-red-500 animate-pulse' : 'text-slate-400'}`}>{message || `[${inputMode === 'quick' ? (currentQ.code[0] + (currentQ.code.length > 1 ? currentQ.code.slice(-1) : '')) : (inputMode === 'radical' ? currentQ.code[0] : currentQ.code)}] æç¤ºï¼š${currentQ.hint}`}</h3>{renderInput()}</motion.div>}</div></motion.div></AnimatePresence></div></div>
                    </div>
                    <div className="flex-1 bg-white relative z-20 shadow-[0_-20px_60px_rgba(0,0,0,0.1)] rounded-t-[2.5rem] p-6 flex flex-col justify-start pt-12"><div className="absolute top-4 left-1/2 transform -translate-x-1/2 w-16 h-1.5 bg-slate-200 rounded-full"></div>{gameState === 'bullet_time' ? (<motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} className="w-full flex flex-col items-center"><h3 className={`font-bold mb-6 text-sm tracking-wider uppercase transition-colors duration-300 ${feedback?.includes('wrong') ? 'text-red-500 animate-pulse' : 'text-slate-400'}`}>{message || `[${inputMode === 'quick' ? (currentQ.code[0] + (currentQ.code.length > 1 ? currentQ.code.slice(-1) : '')) : (inputMode === 'radical' ? currentQ.code[0] : currentQ.code)}] æç¤ºï¼š${currentQ.hint}`}</h3>{renderInput()}</motion.div>) : (<div className="h-full flex flex-col items-center justify-center text-slate-300"><div className="animate-pulse flex flex-col items-center"><LucideIcon icon={Rocket} size={48} className="mb-4 text-slate-200" /><span className="font-bold tracking-widest text-lg">å¥”è·‘ä¸­...</span></div></div>)}</div>
                </div>
            );
        };

        // --- ğŸ  App Component ---
        const App = () => {
            const [view, setView] = useState('home'); 
            const [userName, setUserName] = useState('');
            const [saveData, setSaveData] = useState(null);
            const [config, setConfig] = useState({ 
                mode: 'runner', // 'rpg' or 'runner'
                inputMode: 'radical', // 'radical', 'quick', 'cangjie'
                difficulty: 'normal', // 'easy', 'normal', 'hard'
                category: null, 
                theme: THEMES.FOREST 
            });
            
            const [metaState, setMetaState] = useState({
                coins: 0,
                upgrades: { hp: 0, atk: 0, exp: 0 },
                unlockedArtifacts: ['wand_1', 'robe_1', 'ring_1', 'boots_1']
            });

            useEffect(() => {
                const saved = localStorage.getItem('speedy_adventure_meta');
                if (saved) { try { const parsed = JSON.parse(saved); setMetaState(parsed.metaState || metaState); setUserName(parsed.userName || ''); } catch(e) {} }
            }, []);

            useEffect(() => { localStorage.setItem('speedy_adventure_meta', JSON.stringify({ metaState, userName })); }, [metaState, userName]);

            const goHome = () => setView('home');
            const handleGameEnd = (coinsEarned) => { setMetaState(prev => ({ ...prev, coins: prev.coins + coinsEarned })); setView('mode_select'); };

            const handleExportSave = () => {
                const data = JSON.stringify({ metaState, userName, date: new Date().toISOString() });
                const blob = new Blob([data], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `word_battler_backup.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            };

            const handleImportSave = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.metaState) setMetaState(data.metaState);
                        if (data.userName) setUserName(data.userName);
                        alert("å­˜æª”è®€å–æˆåŠŸï¼");
                    } catch (err) { alert("ç„¡æ•ˆçš„å­˜æª”ï¼"); }
                };
                reader.readAsText(file);
            };

            const handleGameSetupStart = (inputMode, difficulty) => {
                setConfig({ ...config, inputMode, difficulty });
                setView('category_select');
            };

            if (view === 'home') return ( <div className="h-full flex flex-col items-center justify-center bg-slate-900 p-6 text-white"><div className="bg-slate-800 p-8 rounded-3xl shadow-2xl text-center w-full max-w-md border border-slate-700"><LucideIcon icon={Rocket} size={64} className="text-magic-500 mx-auto mb-6" /><h1 className="text-4xl font-black mb-2 text-transparent bg-clip-text bg-gradient-to-r from-magic-300 to-brand-300">é€Ÿæˆå¤§å†’éšª V25</h1><p className="text-slate-400 mb-8">Roguelite çŸ¥è­˜æ·±æ·µ</p><input className="w-full p-4 bg-slate-900 border border-slate-600 rounded-xl text-center text-lg mb-6 text-white focus:border-magic-500 outline-none" placeholder="å¬å–šå¸«ä¹‹å" value={userName} onChange={e=>setUserName(e.target.value)} /><button disabled={!userName} onClick={()=>{AudioEngine.click(); setView('mode_select')}} className="w-full bg-magic-600 hover:bg-magic-500 text-white p-4 rounded-xl font-bold shadow-lg disabled:opacity-50 transition-all flex items-center justify-center gap-2 mb-4"><LucideIcon icon={Play} /> é€²å…¥æ·±æ·µ</button><div className="flex gap-4 justify-center text-sm text-slate-500"><label className="cursor-pointer hover:text-magic-300 flex items-center gap-1"><LucideIcon icon={Upload} size={14}/> è®€å– <input type="file" className="hidden" onChange={handleImportSave}/></label><button onClick={handleExportSave} className="hover:text-magic-300 flex items-center gap-1"><LucideIcon icon={Download} size={14}/> å‚™ä»½</button></div></div></div> );

            if (view === 'mode_select') return ( <div className="h-full bg-slate-950 p-6 overflow-y-auto text-white"><div className="flex justify-between items-center mb-8 max-w-4xl mx-auto"><div className="flex items-center gap-4"><div className="w-12 h-12 bg-magic-900 rounded-full flex items-center justify-center border border-magic-600"><LucideIcon icon={User} className="text-magic-300"/></div><div><h2 className="text-xl font-bold">{userName}</h2><div className="flex items-center gap-1 text-gold-400 text-sm"><LucideIcon icon={Coins} size={14}/> {metaState.coins}</div></div></div><button onClick={()=>setView('home')} className="p-2 bg-slate-800 rounded-full hover:bg-slate-700"><LucideIcon icon={Home} /></button></div><div className="grid gap-6 max-w-4xl mx-auto"><div onClick={()=>setView('meta_shop')} className="bg-gradient-to-r from-slate-900 to-magic-900 p-6 rounded-3xl border border-magic-500/30 cursor-pointer hover:scale-[1.02] transition-transform flex items-center justify-between"><div><h3 className="text-2xl font-bold text-gold-400 mb-1 flex items-center gap-2"><LucideIcon icon={ShoppingBag}/> çŸ¥è­˜è–æ®¿</h3><p className="text-slate-400 text-sm">æ¶ˆè€—çŸ¥è­˜å¹£ï¼Œå¼·åŒ–è‡ªèº«èˆ‡è§£é–éºç‰©</p></div><LucideIcon icon={ArrowLeft} className="rotate-180 text-slate-500" /></div><div className="grid md:grid-cols-2 gap-6">
                <div onClick={()=>{setConfig({...config, mode: 'rpg'}); setView('game_setup')}} className="bg-slate-800 p-6 rounded-3xl border border-slate-700 hover:border-magic-500 transition-colors cursor-pointer group"><LucideIcon icon={Sword} size={40} className="text-purple-400 mb-4" /><h3 className="text-2xl font-bold mb-2 group-hover:text-magic-300">æ·±æ·µè©¦ç…‰ (RPG)</h3><p className="text-slate-400 text-sm mb-6">æŒ‘æˆ°ç„¡é™å±¤æ•¸ï¼ŒRoguelite æˆé•·é«”é©—ã€‚</p><div className="flex justify-end"><LucideIcon icon={Play} size={24} className="text-magic-500 group-hover:scale-110 transition-transform"/></div></div>
                <div onClick={()=>{setConfig({...config, mode: 'runner'}); setView('game_setup')}} className="bg-white p-6 rounded-3xl border border-slate-200 text-slate-800 cursor-pointer hover:border-brand-500 transition-colors group"><LucideIcon icon={Zap} size={40} className="text-yellow-500 mb-4" /><h3 className="text-2xl font-bold mb-2 group-hover:text-brand-600">é€Ÿæˆè·‘é…·</h3><p className="text-slate-500 text-sm mb-6">åæ‡‰åŠ›è¨“ç·´ï¼</p><div className="flex justify-end"><LucideIcon icon={Play} size={24} className="text-brand-500 group-hover:scale-110 transition-transform"/></div></div>
            </div></div></div> );

            if (view === 'meta_shop') return <MetaShop metaState={metaState} setMetaState={setMetaState} onBack={()=>setView('mode_select')} />;
            if (view === 'game_setup') return <GameSetup onStart={handleGameSetupStart} onBack={()=>setView('mode_select')} mode={config.mode} />;

            if (view === 'category_select') return ( 
                <div className="h-full bg-slate-950 p-6 text-white overflow-y-auto">
                    <div className="flex justify-between items-center mb-8 max-w-4xl mx-auto"><h2 className="text-2xl font-bold">é¸æ“‡ç« ç¯€ (é¦–ç¢¼)</h2><button onClick={()=>setView('game_setup')} className="p-2 bg-slate-800 rounded-full"><LucideIcon icon={ArrowLeft} /></button></div>
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 max-w-4xl mx-auto">
                        <button onClick={() => { setConfig({...config, category: null}); setView(config.mode==='rpg'?'game_rpg':'game_runner'); }} className="p-4 bg-magic-900 border-2 border-magic-500 rounded-xl hover:bg-magic-800 transition-all flex flex-col items-center gap-2 col-span-full mb-4">
                            <span className="text-lg font-bold text-magic-300">éš¨æ©ŸæŒ‘æˆ° (æ‰€æœ‰ç« ç¯€)</span>
                        </button>
                        {CHAPTERS.map(chap => (
                            <button key={chap.id} onClick={()=>{setConfig({...config, category:chap.code}); setView(config.mode==='rpg'?'game_rpg':'game_runner')}} className="p-4 bg-slate-800 rounded-xl border border-slate-700 hover:border-brand-500 hover:bg-slate-700 transition-all flex flex-col items-center gap-1 group">
                                <div className="text-2xl font-black text-slate-500 group-hover:text-white">{chap.code}</div>
                                <div className="text-lg font-serif font-bold text-brand-400">{chap.name}</div>
                                <div className="text-xs text-slate-500 mt-1">Chapter {chap.id}</div>
                            </button>
                        ))}
                    </div>
                </div> 
            );

            if (view === 'game_rpg') return <RPGGame user={userName} difficulty={config.difficulty} inputMode={config.inputMode} chapter={config.category} metaState={metaState} onGameEnd={handleGameEnd} onExit={()=>setView('mode_select')} onHome={goHome} />;
            if (view === 'game_rpg_load') return <RPGGame user={userName} difficulty={config.difficulty} inputMode={config.inputMode} chapter={config.category} metaState={metaState} onGameEnd={handleGameEnd} onExit={()=>setView('mode_select')} onHome={goHome} initialData={saveData} />;
            if (view === 'game_runner') return <RunnerGame user={userName} difficulty={config.difficulty} inputMode={config.inputMode} chapter={config.category} currentTheme={config.theme} onExit={()=>setView('category_select')} onHome={goHome} />;

            return null;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
