<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é€Ÿæˆå¤§å†’éšª | Quick Input Adventure</title>
    
    <!-- Core Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'brand': { 50: '#f0f9ff', 100: '#e0f2fe', 500: '#0ea5e9', 600: '#0284c7' },
                        'magic': { 900: '#2e1065', 800: '#4c1d95', 600: '#7c3aed', 500: '#8b5cf6', 300: '#c4b5fd', 100: '#ede9fe' },
                    },
                    fontFamily: {
                        'serif': ['"Noto Serif TC"', '"Songti TC"', 'serif'],
                        'sans': ['"Noto Sans TC"', 'sans-serif'],
                        'mono': ['"Noto Sans Mono"', 'monospace'],
                    },
                    animation: {
                        'run': 'run 0.6s steps(4) infinite',
                        'road': 'road 2s linear infinite',
                        'float': 'float 3s ease-in-out infinite',
                        'shake': 'shake 0.5s cubic-bezier(.36,.07,.19,.97) both',
                        'pulse-glow': 'pulseGlow 2s infinite',
                        'damage-flash': 'damageFlash 0.3s ease-in-out',
                        'float-up': 'floatUp 1s ease-out forwards',
                    },
                    keyframes: {
                        run: { '0%': { transform: 'translateY(0)' }, '50%': { transform: 'translateY(-5px)' }, '100%': { transform: 'translateY(0)' } },
                        road: { '0%': { backgroundPosition: '0 0' }, '100%': { backgroundPosition: '-100% 0' } },
                        float: { '0%, 100%': { transform: 'translateY(0)' }, '50%': { transform: 'translateY(-15px)' } },
                        shake: { '10%, 90%': { transform: 'translate3d(-2px, 0, 0)' }, '20%, 80%': { transform: 'translate3d(4px, 0, 0)' }, '30%, 50%, 70%': { transform: 'translate3d(-6px, 0, 0)' }, '40%, 60%': { transform: 'translate3d(6px, 0, 0)' } },
                        pulseGlow: { '0%, 100%': { opacity: 1, filter: 'brightness(1)' }, '50%': { opacity: 0.8, filter: 'brightness(1.3)' } },
                        damageFlash: { '0%, 100%': { backgroundColor: 'transparent' }, '50%': { backgroundColor: 'rgba(239, 68, 68, 0.3)' } },
                        floatUp: { '0%': { transform: 'translateY(0) scale(1)', opacity: 1 }, '100%': { transform: 'translateY(-50px) scale(1.5)', opacity: 0 } }
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700;900&family=Noto+Serif+TC:wght@700&display=swap');
        html, body, #root { height: 100%; margin: 0; padding: 0; font-family: 'Noto Sans TC', sans-serif; overflow: hidden; touch-action: manipulation; background-color: #f8fafc; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .keyboard-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 4px; }
        .perspective-road { transform: perspective(500px) rotateX(40deg); transform-origin: bottom; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const { motion, AnimatePresence } = window.Motion;
        const { icons } = lucide;
        const { 
            Settings, Volume2, ArrowLeft, Play, User, Trophy, Star, Zap, LayoutGrid, Rocket, Heart, AlertTriangle, 
            CheckCircle, RefreshCw, Keyboard, MousePointer2, Box, Home, Trees, Cloud, Moon, Flag, Timer, Leaf, 
            Smile, Coffee, BookOpen, Sword, Shield, Ghost, Sparkles, Skull, Flame, Plus, Crown, Gift, Hammer, 
            Droplets, Wind, Eye
        } = icons;

        const LucideIcon = ({ icon, size = 24, className = "" }) => icon ? <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{icon.map(([tag, attrs], i) => React.createElement(tag, { ...attrs, key: i }))}</svg> : null;

        // --- ğŸµ Audio Engine ---
        const AudioEngine = {
            ctx: null,
            init: function() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) this.init();
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + duration);
            },
            correct: function() { this.playTone(880, 'sine', 0.1); setTimeout(() => this.playTone(1760, 'sine', 0.2), 100); },
            wrong: function() { this.playTone(150, 'sawtooth', 0.3); setTimeout(() => this.playTone(100, 'sawtooth', 0.4), 150); },
            click: function() { this.playTone(400, 'triangle', 0.05, 0.05); },
            attack: function() { this.playTone(100, 'square', 0.1, 0.3); setTimeout(() => this.playTone(50, 'sawtooth', 0.2, 0.3), 50); }, 
            crit: function() { this.playTone(600, 'square', 0.1, 0.4); setTimeout(() => this.playTone(1200, 'square', 0.2, 0.4), 100); }, 
            hit: function() { this.playTone(80, 'sawtooth', 0.2, 0.3); },
            heal: function() { this.playTone(400, 'sine', 0.5, 0.2); setTimeout(() => this.playTone(600, 'sine', 0.5, 0.2), 200); },
            block: function() { this.playTone(100, 'square', 0.1, 0.3); },
            levelUp: function() { [440, 554, 659, 880, 1108].forEach((f, i) => setTimeout(() => this.playTone(f, 'triangle', 0.3), i * 100)); },
            win: function() { [523, 659, 784, 1046].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.2), i * 150)); },
            lose: function() { [300, 250, 200].forEach((f, i) => setTimeout(() => this.playTone(f, 'sawtooth', 0.3), i * 300)); }
        };

        // --- ğŸ“š Data ---
        const KEYBOARD_MAP = { 'A': 'æ—¥', 'B': 'æœˆ', 'C': 'é‡‘', 'D': 'æœ¨', 'E': 'æ°´', 'F': 'ç«', 'G': 'åœŸ', 'H': 'ç«¹', 'I': 'æˆˆ', 'J': 'å', 'K': 'å¤§', 'L': 'ä¸­', 'M': 'ä¸€', 'N': 'å¼“', 'O': 'äºº', 'P': 'å¿ƒ', 'Q': 'æ‰‹', 'R': 'å£', 'S': 'å°¸', 'T': 'å»¿', 'U': 'å±±', 'V': 'å¥³', 'W': 'ç”°', 'X': 'é›£', 'Y': 'åœ', 'Z': 'é‡' };
        
        const QUESTIONS = [
            { category: "nature", char: "æ˜", code: "AB", first: "A", last: "B", hint: "æ—¥æœˆç‚ºæ˜", decoys: [{char:"æœ¨",code:"D"}, {char:"ç›®",code:"BU"}, {char:"ç”°",code:"W"}] },
            { category: "nature", char: "æ—", code: "DD", first: "D", last: "D", hint: "é›™æœ¨æˆæ—", decoys: [{char:"æ°´",code:"E"}, {char:"ç«",code:"F"}, {char:"å¤§",code:"K"}] },
            { category: "nature", char: "æ—©", code: "AJ", first: "A", last: "J", hint: "å¤ªé™½å‡ºä¾†åé»äº†", decoys: [{char:"å£",code:"R"}, {char:"ç”°",code:"W"}, {char:"ç”²",code:"WL"}] },
            { category: "nature", char: "èŠ±", code: "TP", first: "T", last: "P", hint: "è‰(å»¿)å­—é ­ï¼Œè®ŠåŒ–(åŒ–)çš„å¿ƒ", decoys: [{char:"æœ¨",code:"D"}, {char:"è‰",code:"TA"}, {char:"ç«",code:"F"}] },
            { category: "nature", char: "æµ·", code: "EY", first: "E", last: "Y", hint: "æ°´(E)æµé€²æ¯(OWY)å€‹è§’è½", decoys: [{char:"æ²³",code:"EMR"}, {char:"æ´‹",code:"ETQ"}, {char:"æ³³",code:"EINO"}] },
            { category: "people", char: "æƒ³", code: "DP", first: "D", last: "P", hint: "æœ¨ç›®åœ¨å¿ƒä¸Š", decoys: [{char:"æ‰‹",code:"Q"}, {char:"æ°´",code:"E"}, {char:"æ—¥",code:"A"}] },
            { category: "people", char: "å¥½", code: "VND", first: "V", last: "D", hint: "å¥³å­ç‚ºå¥½", decoys: [{char:"ç”·",code:"WKS"}, {char:"ä¸­",code:"L"}, {char:"å¤§",code:"K"}] },
            { category: "people", char: "ä¼‘", code: "OD", first: "O", last: "D", hint: "äºº(O)é åœ¨æœ¨(D)æ—ä¼‘æ¯", decoys: [{char:"ç«",code:"F"}, {char:"æ°´",code:"E"}, {char:"åœŸ",code:"G"}] },
            { category: "life", char: "åƒ", code: "RN", first: "R", last: "N", hint: "å£(R)ä¹(ON)æ±‚é£Ÿç‰©", decoys: [{char:"æ‰‹",code:"Q"}, {char:"è¶³",code:"RYO"}, {char:"ç›®",code:"BU"}] },
            { category: "life", char: "å–", code: "RV", first: "R", last: "V", hint: "å£(R)æ¸´(APV)å–æ°´", decoys: [{char:"æ—¥",code:"A"}, {char:"æœˆ",code:"B"}, {char:"ç”°",code:"W"}] },
            { category: "life", char: "ç©", code: "MU", first: "M", last: "U", hint: "ç‹(MG)å…ƒ(MMKU)æ°£", decoys: [{char:"åœŸ",code:"G"}, {char:"é‡‘",code:"C"}, {char:"ç«",code:"F"}] },
        ];

        const THEMES = {
            FOREST: { id: 'forest', name: 'æ£®æ—', bg: 'bg-green-100', road: 'from-green-800 to-green-600', decor: Trees },
            SPACE: { id: 'space', name: 'å¤ªç©º', bg: 'bg-slate-900', road: 'from-blue-900 to-slate-800', decor: Moon },
            ANCIENT: { id: 'ancient', name: 'å¤é¢¨', bg: 'bg-amber-50', road: 'from-amber-800 to-amber-600', decor: Cloud }
        };

        const CATEGORIES = [
            { id: 'all', name: 'å…¨éƒ¨', icon: Star, color: 'bg-purple-100 text-purple-600' },
            { id: 'nature', name: 'è‡ªç„¶', icon: Leaf, color: 'bg-green-100 text-green-600' },
            { id: 'people', name: 'äººç‰©', icon: Smile, color: 'bg-amber-100 text-amber-600' },
            { id: 'life', name: 'ç”Ÿæ´»', icon: Coffee, color: 'bg-blue-100 text-blue-600' },
        ];

        // ğŸ›¡ï¸ Roguelike Artifacts
        const RPG_ARTIFACTS = [
            { id: 'vamp_tooth', name: 'å¸è¡€é¬¼ä¹‹ç‰™', icon: Droplets, desc: 'æ”»æ“Šå›å¾© 10% å‚·å®³è¡€é‡', effect: (p) => ({ ...p, lifesteal: p.lifesteal + 0.1, maxHp: p.maxHp + 10 }) },
            { id: 'sharp_stone', name: 'é›·ç¥ç£¨åˆ€çŸ³', icon: Zap, desc: 'æš´æ“Šç‡ +20%', effect: (p) => ({ ...p, critChance: p.critChance + 0.2, atk: p.atk + 5 }) },
            { id: 'spike_shield', name: 'èŠæ£˜ç›¾ç‰Œ', icon: Shield, desc: 'åå½ˆ 20% å—åˆ°å‚·å®³', effect: (p) => ({ ...p, thorns: p.thorns + 0.2, maxHp: p.maxHp + 30 }) },
            { id: 'wind_boots', name: 'é¢¨ä¹‹é´', icon: Wind, desc: 'é–ƒé¿ç‡ +15%', effect: (p) => ({ ...p, dodge: p.dodge + 0.15 }) },
            { id: 'giant_belt', name: 'å·¨äººè…°å¸¶', icon: User, desc: 'æœ€å¤§ HP +50', effect: (p) => ({ ...p, maxHp: p.maxHp + 50, hp: p.hp + 50 }) },
            { id: 'berserk_axe', name: 'ç‹‚æˆ°å£«ä¹‹æ–§', icon: Hammer, desc: 'æ”»æ“ŠåŠ› +15', effect: (p) => ({ ...p, atk: p.atk + 15 }) },
        ];

        // ğŸ‘¾ Monster Types
        const MONSTER_TYPES = [
            { name: 'å²èŠå§†', hpMod: 0.8, atkMod: 0.8, speedMod: 0.8, color: 'text-green-400', icon: Ghost },
            { name: 'è™è ', hpMod: 0.6, atkMod: 1.2, speedMod: 1.5, color: 'text-purple-400', icon: Wind },
            { name: 'çŸ³åƒé¬¼', hpMod: 1.5, atkMod: 1.2, speedMod: 0.6, color: 'text-stone-400', icon: Shield },
            { name: 'æš—å½±åˆºå®¢', hpMod: 0.8, atkMod: 1.5, speedMod: 1.2, color: 'text-red-400', icon: Sword },
            { name: 'å­—éˆé¾', hpMod: 2.0, atkMod: 1.5, speedMod: 1.0, color: 'text-yellow-400', icon: Crown }, // Boss
        ];

        const RPG_SKILLS = [
            { id: 'heal', name: 'æ²»ç™’è¡“', cd: 3, icon: Heart, color: 'bg-green-500', effect: (p) => ({ ...p, hp: Math.min(p.maxHp, p.hp + Math.floor(p.maxHp * 0.3)), log: `æ–½æ”¾æ²»ç™’è¡“ï¼å›å¾© ${Math.floor(p.maxHp * 0.3)} HP` }) },
            { id: 'burst', name: 'çˆ†è£‚é­”æ³•', cd: 5, icon: Flame, color: 'bg-red-500', effect: (p) => ({ ...p, bonusDmg: p.atk * 2, log: 'çˆ†è£‚é­”æ³•è“„åŠ›ï¼ä¸‹æ“Šå‚·å®³ 200%ï¼' }) },
            { id: 'guard', name: 'éµå£', cd: 4, icon: Shield, color: 'bg-blue-500', effect: (p) => ({ ...p, shield: 50, log: 'ç²å¾— 50 é»è­·ç›¾ï¼' }) },
        ];

        // --- âš”ï¸ RPG Game Component ---
        const RPGGame = ({ difficulty, category, onExit, onHome, user }) => {
            // Player State with Roguelike Stats
            const [player, setPlayer] = useState({
                hp: 100, maxHp: 100, atk: 20, level: 1, exp: 0, maxExp: 100,
                critChance: 0.1, critMult: 1.5, lifesteal: 0, thorns: 0, dodge: 0, shield: 0,
                bonusDmg: 0, combo: 0,
                skills: RPG_SKILLS.map(s => ({...s, currentCd: 0})),
                artifacts: []
            });
            
            const [monster, setMonster] = useState({ hp: 100, maxHp: 100, name: 'å²èŠå§†', type: MONSTER_TYPES[0] });
            const [attackGauge, setAttackGauge] = useState(0); 
            const [qIndex, setQIndex] = useState(0);
            const [turn, setTurn] = useState('player'); // player, reward, win, lose
            const [userInput, setUserInput] = useState([]);
            const [combatLog, setCombatLog] = useState("æˆ°é¬¥é–‹å§‹ï¼è«‹è¼¸å…¥é€Ÿæˆç¢¼æ”»æ“Šï¼");
            const [damageText, setDamageText] = useState(null); // { val: string, type: 'crit'|'miss'|'heal'|'normal', id: rand }
            const [rewards, setRewards] = useState([]); 

            const filteredQuestions = useMemo(() => {
                if (category === 'all') return QUESTIONS;
                return QUESTIONS.filter(q => q.category === category);
            }, [category]);
            
            const activeQuestions = filteredQuestions.length > 0 ? filteredQuestions : QUESTIONS;
            const currentQ = activeQuestions[qIndex];

            // Helper for floating text
            const showFloatText = (val, type) => {
                setDamageText({ val, type, id: Math.random() });
                setTimeout(() => setDamageText(null), 1000);
            };

            // Option Generation (Memoized)
            const currentOptions = useMemo(() => {
                if (difficulty === 'advanced') return [];
                const correctOption = difficulty === 'beginner' 
                    ? { label: `${KEYBOARD_MAP[currentQ.first]} (${currentQ.first})`, val: currentQ.first, isCorrect: true }
                    : { label: `${KEYBOARD_MAP[currentQ.first]} + ${KEYBOARD_MAP[currentQ.last]}`, val: currentQ.code, isCorrect: true };

                const safeDecoys = currentQ.decoys.filter(d => difficulty === 'beginner' ? d.code[0] !== currentQ.first : d.code !== currentQ.code);
                const decoyOptions = safeDecoys.slice(0, 2).map(d => {
                    if (difficulty === 'beginner') {
                        const firstCode = d.code[0];
                        return { label: `${d.char} (${firstCode})`, val: firstCode, isCorrect: false };
                    } else {
                        const first = d.code[0];
                        const last = d.code[d.code.length - 1];
                        return { label: `${d.char} (${first}+${last})`, val: first+last, isCorrect: false };
                    }
                });
                return [correctOption, ...decoyOptions].sort(() => Math.random() - 0.5);
            }, [qIndex, difficulty, currentQ]);

            // Monster Logic
            useEffect(() => {
                let interval;
                if (turn === 'player') {
                    interval = setInterval(() => {
                        setAttackGauge(prev => {
                            if (prev >= 100) {
                                // Monster Attack
                                const baseDmg = 10 + (qIndex * 2); // Scaling Dmg
                                const finalDmg = Math.floor(baseDmg * monster.type.atkMod);
                                handlePlayerDamage(finalDmg, `${monster.type.name} ç™¼å‹•æ”»æ“Šï¼`);
                                return 0;
                            }
                            // Speed Logic
                            let increment = 2.5 * monster.type.speedMod;
                            if (difficulty === 'intermediate') increment *= 0.7;
                            if (difficulty === 'advanced') increment *= 0.3; // 30s roughly
                            return prev + increment;
                        });
                    }, 200);
                }
                return () => clearInterval(interval);
            }, [turn, difficulty, monster, qIndex]);

            const handlePlayerDamage = (rawDmg, reason) => {
                // Dodge Check
                if (Math.random() < player.dodge) {
                    showFloatText("MISS", 'miss');
                    setCombatLog(`${reason} ä½†è¢«ä½ é–ƒéäº†ï¼`);
                    return;
                }

                AudioEngine.hit();
                let damage = Math.max(0, rawDmg - player.shield);
                let remainingShield = Math.max(0, player.shield - rawDmg);
                
                // Thorns
                if (player.thorns > 0) {
                    const thornsDmg = Math.floor(rawDmg * player.thorns);
                    setMonster(m => ({ ...m, hp: Math.max(0, m.hp - thornsDmg) }));
                    AudioEngine.block();
                }

                setPlayer(p => ({ ...p, hp: Math.max(0, p.hp - damage), shield: remainingShield, combo: 0 }));
                setCombatLog(`${reason} å—åˆ° ${damage} å‚·å®³ï¼`);
                
                if (damage > 0) showFloatText(`-${damage}`, 'normal');

                if (player.hp - damage <= 0) {
                    setTurn('lose');
                    AudioEngine.lose();
                }
            };

            const resolvePlayerAttack = () => {
                // Stats
                const comboMult = 1 + (player.combo * 0.1);
                let damage = (player.atk + player.bonusDmg) * comboMult;
                
                // Crit Check
                let isCrit = Math.random() < player.critChance;
                if (isCrit) {
                    damage *= player.critMult;
                    AudioEngine.crit();
                } else {
                    AudioEngine.attack();
                }
                
                damage = Math.floor(damage);
                showFloatText(damage, isCrit ? 'crit' : 'normal');

                // Lifesteal
                if (player.lifesteal > 0) {
                    const heal = Math.floor(damage * player.lifesteal);
                    if (heal > 0) {
                        setPlayer(p => ({ ...p, hp: Math.min(p.maxHp, p.hp + heal) }));
                        setTimeout(() => showFloatText(`+${heal}`, 'heal'), 500); // Delayed float
                    }
                }

                setPlayer(p => ({ 
                    ...p, bonusDmg: 0, combo: p.combo + 1,
                    skills: p.skills.map(s => ({ ...s, currentCd: Math.max(0, s.currentCd - 1) }))
                })); 
                
                setMonster(m => ({ ...m, hp: Math.max(0, m.hp - damage) }));
                setCombatLog(`${isCrit ? 'æœƒå¿ƒä¸€æ“Šï¼' : 'æ”»æ“ŠæˆåŠŸï¼'} é€ æˆ ${damage} å‚·å®³ï¼`);
                setAttackGauge(prev => Math.max(0, prev - 10)); // Stagger

                if (monster.hp - damage <= 0) {
                    setTimeout(handleMonsterDefeat, 600);
                } else {
                    setTimeout(() => setUserInput([]), 600);
                }
            };

            const handleMonsterDefeat = () => {
                AudioEngine.levelUp();
                // EXP & Level Up
                let newExp = player.exp + 50;
                let newLevel = player.level;
                let leveledUp = false;
                if (newExp >= player.maxExp) {
                    newExp -= player.maxExp;
                    newLevel++;
                    leveledUp = true;
                }
                
                setPlayer(p => ({
                    ...p, exp: newExp, level: newLevel,
                    maxHp: leveledUp ? p.maxHp + 10 : p.maxHp,
                    atk: leveledUp ? p.atk + 2 : p.atk,
                    hp: leveledUp ? p.maxHp : p.hp // Heal to max on level up? Let's say yes for fun
                }));

                // Pick Rewards
                const pool = RPG_ARTIFACTS.sort(() => 0.5 - Math.random()).slice(0, 3);
                setRewards(pool);
                setTurn('reward');
            };

            const handleSelectReward = (artifact) => {
                AudioEngine.correct();
                const newPlayer = artifact.effect(player);
                setPlayer({ ...newPlayer, artifacts: [...newPlayer.artifacts, artifact] });

                // Spawn Next Monster
                if (qIndex < activeQuestions.length - 1) {
                    setQIndex(q => q + 1);
                    const nextType = MONSTER_TYPES[Math.min(MONSTER_TYPES.length-1, Math.floor(qIndex / 2) + 1)] || MONSTER_TYPES[0];
                    const hpScale = 100 + (qIndex * 30);
                    setMonster({ hp: hpScale * nextType.hpMod, maxHp: hpScale * nextType.hpMod, name: nextType.name, type: nextType });
                    setUserInput([]);
                    setAttackGauge(0);
                    setTurn('player');
                    setCombatLog(`é­é‡ ${nextType.name}ï¼`);
                } else {
                    setTurn('win');
                    AudioEngine.win();
                }
            };

            // Input Handlers
            const handleAttack = (inputVal) => {
                if (turn !== 'player') return;
                let isCorrect = (difficulty === 'beginner' && inputVal === currentQ.first) || 
                                (difficulty === 'intermediate' && inputVal === currentQ.code);
                if (isCorrect) resolvePlayerAttack();
                else handlePlayerDamage(5, "è¼¸å…¥éŒ¯èª¤ï¼");
            };

            const handleKeyClick = (key) => {
                if (turn !== 'player') return;
                if (userInput.length === 0) {
                    if (key === currentQ.first) { AudioEngine.click(); setUserInput([key]); }
                    else { handlePlayerDamage(5, "é¦–ç¢¼éŒ¯èª¤ï¼"); setUserInput([]); }
                } else if (userInput.length === 1) {
                    if (key === currentQ.last) { setUserInput([...userInput, key]); resolvePlayerAttack(); }
                    else { handlePlayerDamage(5, "å°¾ç¢¼éŒ¯èª¤ï¼"); }
                }
            };

            const handleSkill = (skillId) => {
                if (turn !== 'player') return;
                const skillIndex = player.skills.findIndex(s => s.id === skillId);
                const skill = player.skills[skillIndex];
                if (skill.currentCd > 0) return;

                AudioEngine.skill();
                const newP = skill.effect(player);
                const newSkills = [...player.skills];
                newSkills[skillIndex] = { ...skill, currentCd: skill.cd };
                setPlayer({ ...newP, skills: newSkills });
                setCombatLog(newP.log);
            };

            // Physical Keyboard
            useEffect(() => {
                if (difficulty !== 'advanced') return;
                const h = (e) => { const k = e.key.toUpperCase(); if(/^[A-Z]$/.test(k)) handleKeyClick(k); };
                window.addEventListener('keydown', h); return () => window.removeEventListener('keydown', h);
            }, [difficulty, turn, userInput, currentQ]);

            // --- Render ---
            if (turn === 'win') return <div className="absolute inset-0 bg-slate-900 flex flex-col items-center justify-center text-white p-8"><LucideIcon icon={Trophy} size={80} className="text-yellow-400 mb-6 animate-bounce" /><h2 className="text-4xl font-bold mb-4">é€šé—œï¼å‚³å¥‡å¬å–šå¸«ï¼</h2><div className="bg-slate-800 p-6 rounded-2xl mb-8 border border-slate-700 w-full max-w-md"><h3 className="text-lg text-magic-300 mb-4 border-b border-slate-600 pb-2">æœ€çµ‚é…ç½® (Build)</h3><div className="flex flex-wrap gap-2 justify-center">{player.artifacts.map((a,i)=>(<div key={i} className="bg-slate-900 p-2 rounded border border-slate-600 flex items-center gap-2"><LucideIcon icon={a.icon} size={16} className="text-yellow-400" /><span className="text-xs">{a.name}</span></div>))}</div></div><div className="flex space-x-4"><button onClick={onExit} className="bg-slate-700 px-8 py-3 rounded-full font-bold">é¸å–®</button><button onClick={onHome} className="bg-magic-600 px-8 py-3 rounded-full font-bold">ä¸»é </button></div></div>;
            
            if (turn === 'lose') return <div className="absolute inset-0 bg-red-950 flex flex-col items-center justify-center text-white p-8"><LucideIcon icon={Skull} size={80} className="text-red-500 mb-6 animate-pulse" /><h2 className="text-4xl font-bold mb-4 text-red-500">æˆ°æ•—...</h2><p className="text-xl mb-8">è¢« {monster.name} æ“Šå€’äº†ã€‚</p><div className="flex space-x-4"><button onClick={onExit} className="bg-slate-700 px-8 py-3 rounded-full font-bold">é‡è©¦</button><button onClick={onHome} className="bg-red-700 px-8 py-3 rounded-full font-bold">ä¸»é </button></div></div>;

            if (turn === 'reward') return (
                <div className="absolute inset-0 bg-slate-900/95 backdrop-blur flex flex-col items-center justify-center text-white p-4 z-50">
                    <motion.div initial={{scale:0.8}} animate={{scale:1}} className="text-center mb-8"><h2 className="text-3xl font-bold text-yellow-400 mb-2">æˆ°é¬¥å‹åˆ©ï¼</h2><p className="text-slate-300">é¸æ“‡ä½ çš„æˆ°åˆ©å“ (Roguelite)</p></motion.div>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 w-full max-w-4xl">
                        {rewards.map((r, i) => (
                            <button key={i} onClick={() => handleSelectReward(r)} className="bg-slate-800 border-2 border-magic-600 hover:bg-slate-700 p-6 rounded-2xl flex flex-col items-center transition-all hover:-translate-y-2">
                                <div className="p-4 bg-slate-900 rounded-full mb-4"><LucideIcon icon={r.icon} size={40} className="text-yellow-400" /></div>
                                <h3 className="text-xl font-bold mb-2">{r.name}</h3>
                                <p className="text-sm text-slate-400 mb-4">{r.desc}</p>
                                <span className="text-xs bg-magic-900 text-magic-300 px-3 py-1 rounded-full">é¸æ“‡</span>
                            </button>
                        ))}
                    </div>
                </div>
            );

            return (
                <div className="h-full w-full flex flex-col bg-slate-950 text-white font-sans relative overflow-hidden">
                    {/* Top Bar: Stats */}
                    <div className="bg-slate-900/90 p-3 border-b border-slate-800 flex justify-between items-start z-10">
                        <div className="w-1/2">
                            <div className="flex items-center gap-3 mb-2">
                                <div className="w-10 h-10 bg-magic-700 rounded flex items-center justify-center font-bold text-lg border border-magic-500">{player.level}</div>
                                <div className="flex-1">
                                    <div className="flex justify-between text-xs text-slate-400 mb-1"><span>HP {player.hp}/{player.maxHp}</span><span>Shield: {player.shield}</span></div>
                                    <div className="h-3 bg-slate-800 rounded-full overflow-hidden relative"><div className="h-full bg-red-500 transition-all duration-300" style={{width: `${(player.hp/player.maxHp)*100}%`}}></div>{player.shield > 0 && <div className="h-full bg-blue-400/50 absolute top-0 left-0" style={{width: `${(player.shield/player.maxHp)*100}%`}}></div>}</div>
                                </div>
                            </div>
                            {/* Build Icons (Mini) */}
                            <div className="flex gap-1 overflow-hidden h-6">
                                {player.artifacts.map((a, i) => <div key={i} title={a.name} className="bg-slate-800 p-1 rounded"><LucideIcon icon={a.icon} size={12} className="text-yellow-500"/></div>)}
                            </div>
                        </div>
                        <div className="w-1/3 text-right">
                            <div className={`text-sm font-bold mb-1 ${monster.type.color}`}>{monster.name}</div>
                            <div className="h-3 bg-slate-800 rounded-full overflow-hidden mb-1"><div className="h-full bg-red-600 transition-all duration-300" style={{width: `${(monster.hp/monster.maxHp)*100}%`}}></div></div>
                            <div className="h-1 bg-slate-800 rounded-full overflow-hidden w-full mt-1"><motion.div className="h-full bg-yellow-400" style={{width: `${attackGauge}%`}} /></div>
                        </div>
                    </div>

                    {/* Arena */}
                    <div className="flex-1 relative flex flex-col items-center justify-center">
                        <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-magic-900/30 to-slate-950 -z-10"></div>
                        
                        {/* Skills */}
                        <div className="absolute top-4 flex gap-4 z-20">
                            {player.skills.map(s => (
                                <button key={s.id} onClick={() => handleSkill(s.id)} disabled={s.currentCd > 0} className={`w-12 h-12 rounded-full border-2 flex items-center justify-center relative transition-transform active:scale-95 ${s.currentCd > 0 ? 'bg-slate-800 border-slate-600 opacity-50' : `${s.color} border-white shadow-lg`}`}>
                                    <LucideIcon icon={s.icon} size={20} className="text-white" />
                                    {s.currentCd > 0 && <div className="absolute inset-0 bg-black/60 rounded-full flex items-center justify-center font-bold">{s.currentCd}</div>}
                                </button>
                            ))}
                        </div>

                        {/* Monster */}
                        <div className="relative mt-8">
                            <motion.div animate={{ y: [0, -10, 0] }} transition={{ repeat: Infinity, duration: 3 }} className="relative z-10">
                                <div className="w-32 h-32 bg-slate-800 rounded-full border-4 border-magic-500 flex items-center justify-center shadow-[0_0_30px_rgba(139,92,246,0.4)]">
                                    <LucideIcon icon={monster.type.icon} size={60} className={monster.type.color} />
                                    <span className="absolute text-6xl font-serif font-black text-white drop-shadow-md">{currentQ.char}</span>
                                </div>
                            </motion.div>
                            {/* Floating Text */}
                            <AnimatePresence>
                                {damageText && (
                                    <motion.div key={damageText.id} initial={{ y: 0, opacity: 1, scale: 0.5 }} animate={{ y: -50, opacity: 0, scale: 1.2 }} className={`absolute -top-10 left-1/2 transform -translate-x-1/2 font-black text-3xl whitespace-nowrap ${damageText.type === 'crit' ? 'text-yellow-400 text-5xl' : damageText.type === 'miss' ? 'text-blue-300' : damageText.type === 'heal' ? 'text-green-400' : 'text-red-500'}`}>
                                        {damageText.val}
                                    </motion.div>
                                )}
                            </AnimatePresence>
                        </div>

                        <div className="mt-8 text-center h-6 text-magic-200 font-bold">{combatLog}</div>
                    </div>

                    {/* Input */}
                    <div className="bg-slate-900 border-t border-slate-800 p-4 pb-8 rounded-t-3xl">
                        <div className="max-w-3xl mx-auto">
                            {difficulty === 'advanced' ? (
                                <div className="space-y-4">
                                    <div className="flex justify-center gap-2">
                                        <div className={`w-12 h-12 border-2 rounded flex items-center justify-center text-2xl font-bold bg-slate-800 ${userInput[0] ? 'border-magic-500 text-magic-300' : 'border-slate-600 text-slate-600'}`}>{userInput[0] && KEYBOARD_MAP[userInput[0]]}</div>
                                        <div className={`w-12 h-12 border-2 rounded flex items-center justify-center text-2xl font-bold bg-slate-800 ${userInput[1] ? 'border-magic-500 text-magic-300' : 'border-slate-600 text-slate-600'}`}>{userInput[1] && KEYBOARD_MAP[userInput[1]]}</div>
                                    </div>
                                    <div className="keyboard-grid">
                                        {"QWERTYUIOPASDFGHJKLZXCVBNM".split('').map(k => (
                                            <button key={k} onClick={() => handleKeyClick(k)} className="aspect-square bg-slate-800 rounded border border-slate-700 flex flex-col items-center justify-center active:bg-slate-700">
                                                <span className="text-[10px] text-slate-500">{k}</span><span className="text-base text-magic-200 font-serif">{KEYBOARD_MAP[k]}</span>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            ) : (
                                <div className="grid grid-cols-3 gap-4">
                                    {currentOptions.map((opt, i) => (
                                        <button key={i} onClick={() => handleAttack(opt.val)} className="bg-slate-800 border-2 border-magic-600 py-6 rounded-xl text-xl font-bold text-magic-100 active:scale-95">{opt.label}</button>
                                    ))}
                                </div>
                            )}
                        </div>
                    </div>
                    
                    <div className="absolute top-4 right-4 flex gap-2 z-50">
                        <button onClick={onExit} className="p-2 bg-slate-800 rounded-full border border-slate-600 text-white"><LucideIcon icon={ArrowLeft} /></button>
                        <button onClick={onHome} className="p-2 bg-magic-600 rounded-full text-white shadow"><LucideIcon icon={Home} /></button>
                    </div>
                </div>
            );
        };

        // ... RunnerGame and FactoryGame remain mostly the same, included for completeness
        const RunnerGame = ({ difficulty, category, onExit, onHome, currentTheme, user }) => {
            const [score, setScore] = useState(0);
            const [time, setTime] = useState(0);
            const [qIndex, setQIndex] = useState(0);
            const [gameState, setGameState] = useState('running');
            const [userInput, setUserInput] = useState([]);
            const [feedback, setFeedback] = useState(null);
            const [message, setMessage] = useState(null);
            const [qStartTime, setQStartTime] = useState(null);
            
            const filteredQuestions = useMemo(() => category === 'all' ? QUESTIONS : QUESTIONS.filter(q => q.category === category), [category]);
            const activeQuestions = filteredQuestions.length > 0 ? filteredQuestions : QUESTIONS;
            const currentQ = activeQuestions[qIndex];
            const charProgress = (qIndex / activeQuestions.length) * 80;
            const charPosition = gameState === 'win' ? 90 : 10 + charProgress;

            useEffect(() => {
                let interval; if (gameState !== 'win') interval = setInterval(() => setTime(t => t + 1), 1000);
                return () => clearInterval(interval);
            }, [gameState]);

            useEffect(() => {
                let timer; if (gameState === 'running') timer = setTimeout(() => { setGameState('bullet_time'); setQStartTime(Date.now()); }, 2000);
                return () => clearTimeout(timer);
            }, [gameState, qIndex]);

            const currentOptions = useMemo(() => {
                if (difficulty === 'advanced') return [];
                const correct = difficulty === 'beginner' 
                    ? { label: `${KEYBOARD_MAP[currentQ.first]} (${currentQ.first})`, val: currentQ.first, isCorrect: true }
                    : { label: `${KEYBOARD_MAP[currentQ.first]} + ${KEYBOARD_MAP[currentQ.last]}`, val: currentQ.code, isCorrect: true };
                const safeDecoys = currentQ.decoys.filter(d => difficulty === 'beginner' ? d.code[0] !== currentQ.first : d.code !== currentQ.code);
                const decoyOptions = safeDecoys.slice(0, 2).map(d => {
                    if (difficulty === 'beginner') return { label: `${d.char} (${d.code[0]})`, val: d.code[0], isCorrect: false };
                    return { label: `${d.char} (${d.code[0]}+${d.code[d.code.length-1]})`, val: d.code[0]+d.code[d.code.length-1], isCorrect: false };
                });
                return [correct, ...decoyOptions].sort(() => Math.random() - 0.5);
            }, [qIndex, difficulty, currentQ]);

            const handleOptionClick = (val) => {
                if (feedback === 'correct') return;
                let isCorrect = false;
                if (difficulty === 'beginner') isCorrect = val === currentQ.first;
                else if (difficulty === 'intermediate') isCorrect = val === currentQ.code;
                if (isCorrect) processAnswer(true);
                else { AudioEngine.wrong(); setFeedback('wrong'); setMessage(`å†è©¦ä¸€æ¬¡ï¼`); setTimeout(() => { setFeedback(null); setMessage(null); }, 1000); }
            };

            const handleKeyClick = (key) => {
                if (gameState !== 'bullet_time' || difficulty !== 'advanced' || feedback === 'correct') return;
                if (userInput.length === 0) {
                    if (key === currentQ.first) { AudioEngine.click(); setUserInput([key]); setMessage(null); setFeedback(null); }
                    else { AudioEngine.wrong(); setFeedback('wrong-first'); setMessage(`é¦–ç¢¼éŒ¯èª¤ï¼æç¤ºï¼š${currentQ.hint}`); setUserInput([key]); setTimeout(() => { if (userInput.length <= 1) { setFeedback(null); setMessage(null); setUserInput([]); } }, 1000); }
                } else if (userInput.length === 1) {
                    if (key === currentQ.last) { setUserInput([...userInput, key]); processAnswer(true); }
                    else { AudioEngine.wrong(); setFeedback('wrong-second'); setMessage(`å°¾ç¢¼éŒ¯èª¤ï¼æç¤ºï¼š${currentQ.hint}`); setTimeout(() => { setFeedback(null); setMessage(null); }, 1000); }
                }
            };

            useEffect(() => {
                if (difficulty !== 'advanced') return;
                const h = (e) => { const k = e.key.toUpperCase(); if (/^[A-Z]$/.test(k)) handleKeyClick(k); };
                window.addEventListener('keydown', h); return () => window.removeEventListener('keydown', h);
            }, [difficulty, gameState, userInput, feedback]);

            const processAnswer = () => {
                AudioEngine.correct(); setFeedback('correct'); setMessage(null);
                const speedBonus = Math.max(0, Math.floor(50 - ((Date.now() - qStartTime)/1000) * 5));
                setScore(s => s + 100 + speedBonus);
                setTimeout(() => { setFeedback(null); setUserInput([]); if (qIndex < activeQuestions.length - 1) { setQIndex(q => q + 1); setGameState('running'); } else { AudioEngine.win(); setGameState('win'); } }, 1000);
            };

            if (gameState === 'win') return <div className="h-full flex flex-col items-center justify-center bg-brand-50"><LucideIcon icon={Trophy} size={64} className="text-yellow-500 mb-4" /><h2 className="text-3xl font-bold">è·‘é…·å®Œæˆï¼</h2><p className="mb-4">å¾—åˆ†: {score}</p><button onClick={onExit} className="bg-brand-500 text-white px-6 py-2 rounded-full">è¿”å›</button></div>;

            return (
                <div className={`h-full w-full flex flex-col ${currentTheme.bg} overflow-hidden relative`}>
                    <div className="absolute top-4 left-4 flex gap-2 z-20"><button onClick={onExit} className="bg-white/80 p-2 rounded-full"><LucideIcon icon={ArrowLeft} /></button></div>
                    <div className="absolute top-4 right-4 flex gap-2 z-20 bg-white/80 px-4 py-2 rounded-full"><LucideIcon icon={Star} className="text-yellow-500" /><span className="font-bold">{score}</span></div>
                    
                    <div className="relative h-[45%] flex flex-col justify-end overflow-hidden">
                        <div className={`absolute bottom-0 w-full h-1/2 bg-gradient-to-b ${currentTheme.road} perspective-road flex justify-center`}><div className={`w-4 h-full bg-white/30 ${gameState === 'running' ? 'animate-pulse' : ''}`}></div></div>
                        <div className="absolute bottom-10 right-[5%] z-10 flex flex-col items-center"><div className="h-24 w-2 bg-slate-400"></div><LucideIcon icon={Flag} size={48} className="text-red-500 fill-current" /></div>
                        <div className="absolute bottom-8 z-20 transition-all duration-1000 ease-in-out" style={{ left: `${charPosition}%` }}><div className="relative transform -translate-x-1/2"><motion.div animate={gameState === 'running' ? { y: [0, -10, 0] } : { y: 0 }} transition={{ repeat: Infinity, duration: 0.5 }}><div style={{ transform: 'scaleX(-1)', display: 'inline-block' }} className={`text-6xl filter drop-shadow-2xl ${feedback === 'wrong' ? 'animate-shake grayscale' : ''}`}>{feedback === 'wrong' ? 'ğŸ˜µ' : 'ğŸƒ'}</div></motion.div><AnimatePresence><motion.div key={qIndex} initial={{ scale: 0, y: 50, opacity: 0 }} animate={{ scale: gameState === 'bullet_time' ? 1 : 0.2, y: gameState === 'bullet_time' ? -100 : 20, opacity: gameState === 'bullet_time' ? 1 : 0 }} className="absolute bottom-0 left-1/2 transform -translate-x-1/2 z-30 mb-12"><div className="bg-white border-8 border-slate-800 rounded-2xl w-32 h-32 flex flex-col items-center justify-center shadow-2xl"><span className="text-6xl font-serif font-black text-slate-900">{currentQ.char}</span></div></motion.div></AnimatePresence></div></div>
                    </div>

                    <div className="flex-1 bg-white relative z-20 shadow-[0_-20px_60px_rgba(0,0,0,0.1)] rounded-t-[2.5rem] p-6 flex flex-col justify-start pt-12">
                        {gameState === 'bullet_time' ? (
                            <div className="w-full flex flex-col items-center">
                                <h3 className={`font-bold mb-6 text-sm tracking-wider uppercase ${feedback?.includes('wrong') ? 'text-red-500 animate-pulse' : 'text-slate-400'}`}>{message || (difficulty === 'advanced' ? (userInput.length > 0 ? 'è«‹è¼¸å…¥å°¾ç¢¼' : 'è«‹è¼¸å…¥é¦–ç¢¼') : 'é¸æ“‡æ­£ç¢ºéƒ¨ä»¶')}</h3>
                                {difficulty === 'advanced' ? (
                                    <div className="w-full max-w-3xl">
                                        <div className="flex justify-center gap-2 mb-4"><div className="w-12 h-12 border-2 rounded flex items-center justify-center font-bold bg-slate-50">{userInput[0] && KEYBOARD_MAP[userInput[0]]}</div><div className="w-12 h-12 border-2 rounded flex items-center justify-center font-bold bg-slate-50">{userInput[1] && KEYBOARD_MAP[userInput[1]]}</div></div>
                                        <div className="keyboard-grid">{"QWERTYUIOPASDFGHJKLZXCVBNM".split('').map(k => <button key={k} onClick={() => handleKeyClick(k)} className="aspect-square bg-white border rounded flex flex-col items-center justify-center active:bg-slate-100"><span className="text-xs text-slate-400">{k}</span><span className="font-bold">{KEYBOARD_MAP[k]}</span></button>)}</div>
                                    </div>
                                ) : (
                                    <div className="grid grid-cols-3 gap-4 w-full max-w-2xl">{currentOptions.map((opt, i) => <button key={i} onClick={() => handleOptionClick(opt.val)} className="py-6 rounded-xl text-xl font-bold bg-white border-2 border-slate-100 shadow-lg active:scale-95 hover:bg-slate-50">{opt.label}</button>)}</div>
                                )}
                            </div>
                        ) : (
                            <div className="h-full flex flex-col items-center justify-center text-slate-300"><div className="animate-pulse flex flex-col items-center"><LucideIcon icon={Rocket} size={48} className="mb-4 text-slate-200" /><span className="font-bold tracking-widest text-lg">å¥”è·‘ä¸­...</span></div></div>
                        )}
                    </div>
                </div>
            );
        };

        const FactoryGame = ({ onExit, onHome, user }) => { /* ... Factory Game Code Same as V6 ... */ return <div className="h-full flex items-center justify-center bg-slate-100">å·¥å» æ¨¡å¼ç¶­è­·ä¸­ <button onClick={onExit} className="ml-4 p-2 bg-white rounded shadow">è¿”å›</button></div> };

        // --- ğŸ“± Main App Container ---
        const App = () => {
            const [view, setView] = useState('home'); 
            const [userName, setUserName] = useState('');
            const [config, setConfig] = useState({ difficulty: 'beginner', category: 'all', theme: THEMES.FOREST, mode: 'runner' });
            const goHome = () => setView('home');

            if (view === 'home') return <div className="h-full flex flex-col items-center justify-center bg-brand-50 p-6"><div className="bg-white p-8 rounded-3xl shadow-xl text-center w-full max-w-md"><LucideIcon icon={Rocket} size={48} className="text-brand-500 mx-auto mb-4" /><h1 className="text-3xl font-black text-slate-800 mb-4">é€Ÿæˆå¤§å†’éšª V7</h1><input className="w-full p-4 border-2 rounded-xl mb-4 text-center text-lg" placeholder="è¼¸å…¥åå­—" value={userName} onChange={e=>setUserName(e.target.value)} /><button disabled={!userName} onClick={()=>{AudioEngine.click(); setView('mode_select')}} className="w-full bg-brand-500 text-white p-4 rounded-xl font-bold shadow-lg disabled:opacity-50">é–‹å§‹</button></div></div>;

            if (view === 'mode_select') return (
                <div className="h-full bg-slate-50 p-6 overflow-y-auto">
                    <div className="flex justify-between items-center mb-8"><div><h2 className="text-2xl font-bold">ä½ å¥½ï¼Œ{userName}</h2></div><button onClick={goHome}><LucideIcon icon={Home} /></button></div>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-4xl mx-auto">
                        <div className="bg-white p-6 rounded-3xl shadow-lg border border-slate-100 relative overflow-hidden">
                            <div className="relative z-10"><LucideIcon icon={Zap} size={32} className="text-yellow-500 mb-4" /><h3 className="text-2xl font-bold mb-2">é€Ÿæˆå¤§å†’éšª (è·‘é…·)</h3><div className="space-y-2">{['beginner','intermediate','advanced'].map(d=><button key={d} onClick={()=>{setConfig({...config, mode:'runner', difficulty:d}); setView('category_select')}} className="w-full p-3 bg-yellow-50 text-yellow-700 font-bold rounded-xl text-left">{(d==='beginner'?'ğŸŸ¢ åˆéš':d==='intermediate'?'ğŸŸ¡ ä¸­éš':'ğŸ”´ é«˜éš')}</button>)}</div></div>
                        </div>
                        <div className="bg-slate-800 p-6 rounded-3xl shadow-lg border border-slate-700 relative overflow-hidden text-white">
                            <div className="relative z-10"><LucideIcon icon={Sword} size={32} className="text-purple-400 mb-4" /><h3 className="text-2xl font-bold mb-2">å­—éˆå¬å–šå¸« (RPG)</h3><p className="text-sm text-slate-400 mb-4">Roguelite æˆ°é¬¥ï¼æ‰“å¯¶ã€å‡ç´šï¼</p><div className="space-y-2">{['beginner','intermediate','advanced'].map(d=><button key={d} onClick={()=>{setConfig({...config, mode:'rpg', difficulty:d}); setView('category_select')}} className="w-full p-3 bg-slate-700 text-purple-300 font-bold rounded-xl text-left border border-slate-600">{(d==='beginner'?'ğŸŸ¢ å­¸å¾’':d==='intermediate'?'ğŸŸ¡ æ³•å¸«':'ğŸ”´ è³¢è€…')}</button>)}</div></div>
                        </div>
                    </div>
                </div>
            );

            if (view === 'category_select') return (
                <div className="h-full bg-slate-50 p-6">
                    <div className="flex justify-between items-center mb-8"><h2 className="text-2xl font-bold">é¸æ“‡ç¯„ç–‡</h2><button onClick={()=>setView('mode_select')}><LucideIcon icon={ArrowLeft} /></button></div>
                    <div className="grid grid-cols-2 gap-4 max-w-2xl mx-auto">
                        {CATEGORIES.map(cat => <button key={cat.id} onClick={()=>{setConfig({...config, category:cat.id}); setView(config.mode==='rpg'?'game_rpg':'game_runner')}} className="p-6 bg-white rounded-2xl shadow-sm border-2 border-transparent hover:border-brand-200 flex flex-col items-center"><LucideIcon icon={cat.icon} size={32} className={cat.color.split(' ')[1]} /><span className="font-bold mt-2">{cat.name}</span></button>)}
                    </div>
                </div>
            );

            if (view === 'game_runner') return <RunnerGame user={userName} {...config} onExit={()=>setView('category_select')} onHome={goHome} />;
            if (view === 'game_rpg') return <RPGGame user={userName} {...config} onExit={()=>setView('category_select')} onHome={goHome} />;
            return null;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
